-- Guénolé Lallement
-- draw-octant
-- VHDL & Logic Synthesis Coursework

library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

-- Declaration of the entity draw_octant
entity draw_octant is
  port(
    clk, resetx, draw, xbias, disable : in  std_logic;
    xin, yin                          : in  std_logic_vector(11 downto 0);
    done                              : out std_logic;
    x, y                              : out std_logic_vector(11 downto 0)
    );
end entity draw_octant;

-- Declaration of the archietcture draw_octant
architecture comb of draw_octant is

  -- Intern signals
  signal done1                    : std_logic;
  signal x1, y1                   : std_logic_vector(11 downto 0);
  signal xincr, yincr, xnew, ynew : std_logic_vector(11 downto 0);
  signal error                    : std_logic_vector(11 downto 0);
  signal err1, err2               : std_logic_vector(12 downto 0);

  -- Alias
  alias slv is std_logic_vector;
  alias sg is signed;

begin


  -- Combinational process to generate err1, err2 and done
  C1 : process(error, xincr, yincr, x1, y1, xnew, ynew, resetx, draw)

    -- variable err1_v, err2_v : slv(12 downto 0);

  begin
    -- err1 = |error + yincr|
    err1 <= slv(abs(sg(error) + resize(sg(yincr), 13)));

    -- err2 = |error+yincr - xincr|
    err1 <= slv(abs(sg(error) + resize(sg(yincr), 13) + resize(sg(xincr), 13)));

    -- done : x = xnew and y = ynew and reset = 0 and draw = 0
    if x1 = xnew and y1 = ynew and resetx = '0' and draw = '0' then
      done <= '1';
    else
      done <= '0';
    end if;
  end process C1;

--  Registered process
  R1 : process(clk, resetx, disable)
  begin
    -- WAIT UNTIL clk'event AND clk = '1';
    if rising_edge(clk) then
      if disable = '0' then             -- disable low
        if resetx = '1' then            -- set value to the reset (high)
          error <= (others => '0');
          x     <= sg(xin);
          y     <= sg(yin);
          xincr <= (others => '0');
          yincr <= (others => '0');
          xnew  <= sg(xin);
          ynew  <= sg(yin);
        elsif err1 > err2 or (err1 = err2 and xbias = '0') then
          y1    <= y1 + 1;
          x1    <= x1 + 1;
          error <= error + signed(yincr) - signed(xincr);
        elsif err1 < err2 or (err1 = err2 and xbias = '1') then
          x1    <= x1 + 1;
          error <= error + signed(yincr);
        elsif draw = '1' then           -- draw high
          xincr <= unsigned(xin)-x1;
          yincr <= unsigned(yin)-y1;
          xnew  <= unsigned(xin);
          ynew  <= unsigned(yin);
        elsif done = '1' then           -- done high
          null;                         -- no change in input



        end process R1;

        end architecture comb;
