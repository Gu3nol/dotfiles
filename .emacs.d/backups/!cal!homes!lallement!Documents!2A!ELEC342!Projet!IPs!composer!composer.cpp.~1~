/*
 * =============================================================================
 *
 *       Filename:  video_in.cpp
 *
 * =============================================================================
 */


#include <cstdio>

#include <fstream>
#include <sstream>
#include <iomanip>

#include "video_in.h"


#define tmpl(x) template<typename wb_param> x VideoIn<wb_param>



namespace soclib { namespace caba {
	
	tmpl(/**/)::VideoIn (sc_module_name name )
		   :sc_core::sc_module(name), p_clk("p_clk"),p_resetn("p_resetn"), p_wb("p_wb"), p_wb_slave("p_wb_slave"),
		   master0(p_clk,p_wb)
	{
	    // sc thread
	    SC_THREAD(main_loop);
	    // no sensitivity list, waits have to be explicit
	}
	
	// main process
	tmpl(void)::main_loop()
	{
	    // handle a reset cmd
	    bool reset_done = false;
	    
	    uint8_t  MASK[20] = {
		0xa, 0x5, 0xa, 0x5, 0xa, 0x5, 0xa, 0x5, 0xa, 0x5,
		0xa, 0x5, 0xa, 0x5, 0xa, 0x5, 0xa, 0x5, 0xa, 0x5
	    };
	    uint8_t DATA[20*4] = {
		0x1,  0x2,  0x3,  0x4,
		0x5,  0x6,  0x7,  0x8,
		0x9,  0xa,  0xb,  0xc,
		0xd,  0xe,  0xf,  0x10,
		0x11, 0x12, 0x13, 0x14,
		0x15, 0x16, 0x17, 0x18,
		0x19, 0x1a, 0x1b, 0x1c,
		0x1d, 0x1e, 0x1f, 0x20,
		0x21, 0x22, 0x23, 0x24,
		0x25, 0x26, 0x27, 0x28,
		0x29, 0x2a, 0x2b, 0x2c,
		0x2d, 0x2e, 0x2f, 0x30,
		0x31, 0x32, 0x33, 0x34,
		0x35, 0x36, 0x37, 0x38,
		0x39, 0x3a, 0x3b, 0x3c,
		0x3d, 0x3e, 0x3f, 0x40,
		0x41, 0x42, 0x43, 0x44,
		0x45, 0x46, 0x47, 0x48,
		0x49, 0x4a, 0x4b, 0x4c,
		0x4d, 0x4e, 0x4f, 0x50,
	    };
	    
	    uint8_t RDATA[20*4];
	    
	    for (;;) {
		
		if (!p_resetn) // reset
		    {
			master0.reset();
			reset_done = true;
		    }
		else // clk event
		    {
			int val;
			// check if the reset has been done
			if (!reset_done)
			    {
#ifdef SOCLIB_MODULE_DEBUG
				std::cout
				    << name()
				    << " : has not been reseted yet!!!"
				    << std::endl;
#endif
				wait(p_clk.posedge_event());
				continue;
			    }
			// Call to blocking functions is allowed
			wait_cycles(20);
			// single write of 4 bytes 0xC01dCafe @0x40000000
			master0.wb_write_at(0x40000000,0xf,0xC01dCafe);
			// single read @0x40000000
			val = master0.wb_read_at(0x40000000);
			// Print...
			std::cout << "FIRST READ VAL " << std::hex << val << std::endl;
			
			wait_cycles(20);
			master0.wb_write_at(0x40000000,0xf,0xbbbbbbbb);
			wait_cycles(20);
			val = master0.wb_read_at(0x40000000);
			std::cout << "SECOND READ VAL " << std::hex << val << std::endl;
			
			
			wait_cycles(30);
			// write a data block of 20 "words" starting @0x40001000
			// DATA and MASK are the pointer to the array containning the data
			master0.wb_write_blk(0x40001000,MASK,DATA,20);
			wait_cycles(30);
			// Read a block of 20 words
			// The result is stored in RDATA which has been allocated first
			master0.wb_read_blk(0x40001000,20,RDATA);
			//Print
			for (int i=0; i<20; i++)
			    {
				std::cout << "Read value " << std::dec << i
					  << " : 0x" ;
				for (int j=0; j<4; j++)
				    std::cout <<std::setfill ('0') << std::setw (2) << std::hex << std::noshowbase
					      << (unsigned int)RDATA[4*i+j] ;
				
				std::cout << std::endl;
			    }
			
			std::cout << "Second block write" << std::endl;

			wait_cycles(30);
			// write a data block of 20 "words" starting @0x40001000
			// DATA is the pointer to the array containning the data
			// MASK is NULL so SEL is set to 0xFF (all bytes are written)
			master0.wb_write_blk(0x40001000,NULL,DATA,20);
			wait_cycles(30);
			// Read a block of 20 words
			// The result is stored in RDATA which has been allocated first
			master0.wb_read_blk(0x40001000,20,RDATA);
			//Print
			for (int i=0; i<20; i++)
			    {
				std::cout << "Read value " << std::dec << i
					  << " : 0x" ;
				for (int j=0; j<4; j++)
				    std::cout <<std::setfill ('0') << std::setw (2) << std::hex << std::noshowbase
					      << (unsigned int)RDATA[4*i+j] ;

				std::cout << std::endl;
			    }

			wait_cycles(30);
			// Printing statistics
			std::cout << "END OF SIM..." << master0 << std::endl;
			// Or
			master0.print_stats();
			// Reset The master0 resets the its statistic counters
			master0.reset();
			master0.print_stats();

			// Eventually stop the simulation
			sc_core::sc_stop();

		    }

		// wait rising edge of clk
		wait(p_clk.posedge_event());

	    } // infinite loop

	}


	// wait cycles
	tmpl(void):: wait_cycles (uint32_t delay)
	{
#ifdef SOCLIB_MODULE_DEBUG
	    std::cout
		<< name()
		<< " wait start @" << sc_time_stamp()
		<< std::endl;
#endif
	    while (delay--) {
		wait(p_clk.posedge_event());
	    }
#ifdef SOCLIB_MODULE_DEBUG
	    std::cout
		<< name()
		<< " wait end @" << sc_time_stamp()
		<< std::endl;
#endif
	}

    }}// namespace

