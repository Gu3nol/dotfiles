---------------------------------------------------------
-- Top level Control Logic Unit Input generation
-- clu.vhd
-- MSc Project 2015
-- @Author: Guénolé LALLEMENT

-- This VHDL code is used to generate the inputs for the
-- CLU

-- It is for TB purposed only
--------------------------------------------------------

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

-- Declaration of the entity
ENTITY clu_inputs IS
  PORT(
    -- Master input clock
    mclk : IN  std_logic;
    -- Reset
    nrst : IN  std_logic;
    -- Handshake signal
    rdy  : IN  std_logic;
    -- SPI in
    din  : OUT std_logic_vector(15 DOWNTO 0)
    );
END ENTITY clu_inputs;

-- Declaration of the architecture
ARCHITECTURE rtl OF clu_inputs IS
  -- Constants definining commands from the host CPU to CLU using SPI
  CONSTANT op_stop  : std_logic_vector(1 DOWNTO 0) := "11";
  CONSTANT op_start : std_logic_vector(1 DOWNTO 0) := "01";
  CONSTANT op_reset : std_logic_vector(1 DOWNTO 0) := "10";

  -- Constants definining commands from the CLU to the host CPU using SPI
  CONSTANT st_rdy   : std_logic_vector(1 DOWNTO 0) := "11";
  CONSTANT st_wip   : std_logic_vector(1 DOWNTO 0) := "01";
  CONSTANT st_reset : std_logic_vector(1 DOWNTO 0) := "10";

  SIGNAL op_cmd_i      : std_logic_vector(1 DOWNTO 0);
  SIGNAL array_coord_i : std_logic_vector(5 DOWNTO 0);
  SIGNAL anag_coord_i  : std_logic_vector(3 DOWNTO 0);

  CONSTANT zero_pad : std_logic_vector(3 DOWNTO 0) := (OTHERS => '0');

BEGIN

  outputs : PROCESS(mclk)
  BEGIN
    IF rising_edge(mclk) THEN
      op_cmd_i      <= op_start;
      IF nrst = '0' THEN
        op_cmd_i      <= op_reset;
        anag_coord_i  <= (OTHERS => '0');
        array_coord_i <= (OTHERS => '0');
      ELSE
        IF rdy = '1' THEN
          anag_coord_i  <= std_logic_vector(unsigned(anag_coord_i) + 1);
          array_coord_i <= std_logic_vector(unsigned(array_coord_i) + 1);
        ELSE
          --op_cmd_i      <= op_stop;
          anag_coord_i  <= anag_coord_i;
          array_coord_i <= array_coord_i;
        END IF;
      END IF;
    END IF;
  END PROCESS outputs;

  --output_op_cmd : PROCESS(rdy, nrst)
  --BEGIN
  --  IF nrst = '0' THEN
  --    op_cmd_i <= op_reset;
  --  ELSE
  --    IF rdy = '1' THEN
  --      op_cmd_i <= op_start;
  --    ELSE
  --      op_cmd_i <= op_stop;
  --    END IF;
  --  END IF;
  --END PROCESS output_op_cmd;

  din <= zero_pad & anag_coord_i & op_cmd_i & array_coord_i;

END rtl;
