/* timer.c */

#include "timer.h"
#include "gpio.h"

#define TCON          (*(volatile uint32_t *)  0x01D50008)   // registre de contrÃ´le du timer
#define TCFG0         (*(volatile uint32_t *)  0x01D50000)   // prescaler
#define TCNTB(number) (*(volatile uint16_t *)  (0x01D5000C + 0xC*number)) // registre counter
#define TCMPB(number) (*(volatile uint16_t *)  (0x01D50010 + 0xC*number)) // registre comparateur
#define TCNTO(number) (*(volatile uint32_t *)  (0x01D50014 + 0xC*number)) // registre d'observation

void timer_frequency(uint8_t frequency) {
  if (timer_number > 5) return;
  switch(timer_number) {
  case 0 :
  case 1 :
    TCFG0 &= ~(0xFF);
    TCFG0 |= (uint8_t)PRESCALER(frequency);
    break;
  case 2 :
  case 3 :
    TCFG0 &= ~(0xFF<<8);
    TCFG0 |= ((uint8_t)PRESCALER(frequency))<<8;
    break;
  case 4 :
  case 5 :
    TCFG0 &= ~(0xFF<<16);
    TCFG0 |= ((uint8_t)PRESCALER(frequency))<<16;
    break;

}

void timer_count(uint8_t timer_number, uint16_t value) {
  if (timer_number > 5) return;
  TCNTB(timer_number) = value;
}

uint32_t get_timer(uint8_t timer_number) {
  return TCNTO(timer_number);
}

void timer_start(uint8_t timer_number) {
  if (timer_number > 5) return;
  gpio_pin_data(&TCON, 0x1<<(8*timer_number), ON);
}

void timer_stop(uint8_t timer_number) {
  if (timer_number > 5) return;
  gpio_pin_data(&TCON, 0x1<<(8*timer_number), OFF);
}

 void timer_manuel_reload(uint8_t timer_number, uint8_t value) {
  if (timer_number > 5) return;
  gpio_pin_data(&TCON, 0x1<<(8*timer_number+3), value);
}

void timer_auto_reload(uint8_t timer_number, uint8_t value) {
  if (timer_number > 5) return;
  gpio_pin_data(&TCON, 0x1<<(8*timer_number+2), value);
}

void timer_set(uint8_t timer_number, uint16_t value) {
  if (timer_number > 5) return;
  timer_count(timer_number, value);
  timer_stop(timer_number);
  timer_manuel_reload(timer_number, UPDATE);
  timer_start(timer_number);
  timer_manuel_reload(timer_number, NO_OPERATION);
}

