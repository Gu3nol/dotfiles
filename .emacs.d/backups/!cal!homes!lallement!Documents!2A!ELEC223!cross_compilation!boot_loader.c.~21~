/* boot_loader.c */

#include <stdint.h>
#include "serial.h"

#define L 0x4C
#define R 0x52
#define G 0x47

/* Interface pour répondre aux commande envoyées via port série */
void boot_interface() {

  char buffer[15];
  char address[8];
  char cmd;
  int  i;

  if(i>12) {
    serial_puts("ARM >> : ERREUR : Trop d'arguments");
    serial_flush();
  }

  c = serial_getc();


  switch(cmd) {
  case (c == 'L'):
    load_address(address);
    break;
  case (c == 'R'):
    go_adress(address);
    break;
  case (c == 'G'):
    read_address(address);
    break;
  default:
  }


  buffer[i] = c;
  i++;



}
/* Stocke les octets arrivant sur le port en RAM à l'adresse spécifiée  */
void load_address(uint32_t address) {
}

/* Rransfert le contrôle à ladresse spécifiée */
void go_address(uint32_t address) {
}

/* Affiche le contenue de la mémoire à l'adresse spécifiée */
void read_address(uint32_t address) {
  address &= ~(0x3); // On aligne l'adresse correctement
  serial_puts("ARM >> READ @:");
  serial_puts(h2a(address));
  serial_puts(h2a(*((volatile uint32_t *) address)));
}


uint32_t parser() {

}

/*************************************************************
 * Fonctions
 * h2a : héxadécimal vers ascii
 * atoi : ascii vers décimal
 *************************************************************/

char* h2a(uint32_t hex) {

}

uint32_t atoi(char *c) {
  uint32_t result = 0;

  for (int i = 0; str[i] != '\0'; ++i)
    result = result*10 + str[i] - '0';

  return res;
}
