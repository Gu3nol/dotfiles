-- Guénolé Lallement
-- ex1 - draw-octant
-- VHDL & Logic Synthesis Coursework

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

-- Declaration of the entity draw_octant
ENTITY draw_octant IS
  PORT(
    clk, resetx, draw, xbias, disable : IN  std_logic;
    xin, yin                          : IN  std_logic_vector(11 DOWNTO 0);
    done                              : OUT std_logic;
    x, y                              : OUT std_logic_vector(11 DOWNTO 0)
    );
END ENTITY draw_octant;

-- Declaration of the archietcture draw_octant
ARCHITECTURE comb OF draw_octant IS

  -- Intern signals
  SIGNAL done1                    : std_logic;
  SIGNAL x1, y1                   : std_logic_vector(11 DOWNTO 0);
  SIGNAL xincr, yincr, xnew, ynew : std_logic_vector(11 DOWNTO 0);
  SIGNAL error                    : std_logic_vector(12 DOWNTO 0);
  -- Changed the size of error to 13 bit to avoid overflow
  SIGNAL err1, err2               : std_logic_vector(12 DOWNTO 0);
  SIGNAL err1_v, err2_v           : signed(12 DOWNTO 0);

  -- Alias
  ALIAS slv IS std_logic_vector;
  ALIAS sg IS signed;
  ALIAS unsg IS unsigned;

BEGIN

  -- Combinational process to generate err1, err2 and done
  C1 : PROCESS(error, xincr, yincr, x1, y1, xnew, ynew, resetx, draw)
  BEGIN
    -- err1 = |error + yincr|
    err1_v <= (sg(error) + resize(sg(yincr), error'length));
    --err1_v <= (sg(error) + sg('0' & yincr));

    -- err2 = |error + yincr - xincr|
    err2_v <= (sg(error) + sg('0' & yincr) - sg('0' & xincr));

    -- done : x = xnew and y = ynew and reset = 0 and draw = 0
    done1 <= '0';
    IF x1 = xnew AND y1 = ynew AND resetx = '0' AND draw = '0' THEN
      done1 <= '1';
    END IF;
  END PROCESS C1;

  --  Registered process
  R1 : PROCESS(clk)
  BEGIN
    --wait until clk'event and clk = '1';
    IF rising_edge(clk) THEN
      IF disable = '0' THEN             -- disable low
        IF resetx = '1' THEN            -- set value to the reset (high)
                                        -- synchronous reset
          REPORT "-- resetx --";        -- comment for debug
          error <= (OTHERS => '0');
          x1    <= xin;                 -- we modify x using x1
          y1    <= yin;                 -- we modify y using y1
          xincr <= (OTHERS => '0');
          yincr <= (OTHERS => '0');
          xnew  <= xin;
          ynew  <= yin;
        ELSIF draw = '1' THEN           -- draw high
          REPORT "-- draw --";          -- comment for debug
          xincr <= slv(sg(xin)-sg(x1));
          yincr <= slv(sg(yin)-sg(y1));
          xnew  <= xin;
          ynew  <= yin;
        ELSIF done1 = '1' THEN          -- done high
          REPORT "-- done --";          -- comment for debug
          NULL;                         -- no change in input
        ELSIF err1 > err2 OR (err1 = err2 AND xbias = '0') THEN
          REPORT "-- err1 > err2 --";  -- comment for debug
          error <= slv(err2_v);
          x1    <= slv(sg(x1) + 1);
          y1    <= slv(sg(y1) + 1);
        ELSIF err1 < err2 OR (err1 = err2 AND xbias = '1') THEN
          REPORT "-- err1 < err2 --";  -- comment for debug
          error <= slv(err1_v);
          x1    <= slv(sg(x1) + 1);
        END IF;
      ELSE
        NULL;                           -- condition if disable not 0
      END IF;
    END IF;
  END PROCESS R1;

-- assign permanent signals
  x    <= x1;
  y    <= y1;
  err1 <= slv(ABS(err1_v));
  err2 <= slv(ABS(err2_v));
  done <= done1;
END ARCHITECTURE comb;
