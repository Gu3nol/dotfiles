/*
 * =============================================================================
 *
 *       Filename:  video_in.cpp
 *
 * =============================================================================
 */

module VideoIn (
                input signal_clk,
                input pixel_clk,
                input p_resetn,
                input frame_valid,
                input line_valid,
                input pixel_in,
                output p_int,
                // WB slave signal
                input  [31:0] p_wb_slave_DAT_I,
                output [31:0] p_wb_slave_DAT_O,
                input  [31:0] p_wb_slave_ADR_I,
                output p_wb_slave_ACK_O,
                input  p_wb_slave_CYC_I,
                output p_wb_slave_ERR_O,
                input  p_wb_slave_LOCK_I,
                output p_wb_slave_RTY_O,
                input  [3:0]p_wb_slave_SEL_I,
                input  p_wb_slave_STB_I,
                input  p_wb_slave_WE_I



#include <cstdio>

#include <fstream>
#include <sstream>
#include <iomanip>

#include "video_in.h"


#define tmpl(x) template<typename wb_param> x VideoIn<wb_param>
#define MASK 0xFF

namespace soclib { namespace caba {

	tmpl(/**/)::VideoIn (sc_module_name name )
		:sc_core::sc_module(name), signal_clk("signal_clk"), pixel_clk("pixel_clk"), signal_resetn("p_resetn"), frame_valid("frame_valid"), line_valid("line_valid"), pixel_in("pixel_in"), p_int("p_int"), p_wb("p_wb"), p_wb_slave("p_wb_slave"),master0(signal_clk,p_wb)
	{
		// sc thread
		SC_THREAD(write_loop);
		sensitive << signal_clk.pos() << signal_resetn;
		// no sensitivity list, waits have to be explicit
		SC_THREAD(read_input);
		sensitive << pixel_clk.pos() << signal_resetn;

		SC_METHOD(slave);
		sensitive << signal_clk.pos();

		//Init Variables
		address_offset = 0;
		current_buffer = 0;
		run = false;
		w_index = 0;
		sel = 0;
		send = 0;
	}

	// process which writes on the bus
	tmpl(void)::write_loop()
	{
			if (!signal_resetn) {
reset:
				current_address_base = 0;
				address_offset = 0;
				p_int = false;
				master0.reset();
				wait();
			}
			while (true) {
				p_int = false;
				if (run) {
					if (send) {
						if (address_offset == 0)
							current_address_base = next_address_base;
						master0.wb_write_blk(current_address_base+address_offset, NULL, pixel_buffer[sel], BURST_SIZE/4);
						// TODO sended
						send = false;
						address_offset += BURST_SIZE;
						/* This part may be problemful in the future */
						if(address_offset == IMAGE_SIZE) {
							address_offset = 0;
							p_int = true;
							std::cout << name() << ": " <<master0 << std::endl;
						}
					}
				}
				wait();
				if (!signal_resetn) goto reset;
			}
	}

	// process which writes on the bus
	tmpl(void)::read_input()
	{
		bool synced =false;
		if (!signal_resetn) {
reset:
			send = false;
			synced=false;
			sel = 0;
			w_index = 0;
			wait();
		}
		while (true) {
			if (run) {
				if (!synced) {
					while (frame_valid || line_valid)
						wait();
					synced = true;
					std::cout << name() << "synced on input" << std::endl;
				}
				if (frame_valid && line_valid && synced){
					pixel_buffer[!sel][w_index] = pixel_in;
					w_index++;
					if (w_index == BURST_SIZE) {
						w_index = 0;
						sel = !sel;
						send = true;
						//std::cout << name() << ": A burst buffer is ready to be sent" << std::endl;
					}
				}
			}
			if(!signal_resetn)
				goto reset;
			wait();
		}
	}


	// wait cycles
	tmpl(void):: wait_cycles (uint32_t delay)
	{
#ifdef SOCLIB_MODULE_DEBUG
		std::cout
			<< name()
			<< " wait start @" << sc_time_stamp()
			<< std::endl;
#endif
		while (delay--) {
			wait(signal_clk.posedge_event());
		}
#ifdef SOCLIB_MODULE_DEBUG
		std::cout
			<< name()
			<< " wait end @" << sc_time_stamp()
			<< std::endl;
#endif
	}

	// State transitions on the rising edge of clock
	tmpl(void)::slave() {

		// Synchronous reset
		if (signal_resetn == false) {
			p_wb_slave.DAT_O = 0;
			p_wb_slave.ACK_O = false;
			//  TODO: all outputs have to be set somewhere
			next_address_base = 0;
			run = false;
		}

		p_wb_slave.ACK_O = false;
		p_wb_slave.DAT_O = 0;

		if (p_wb_slave.STB_I.read() && !p_wb_slave.ACK_O.read())
		{
			// ACK for either a read or a write request
			p_wb_slave.ACK_O = true;
			uint32_t laddr = p_wb_slave.ADR_I.read() & MASK;

			if (p_wb_slave.WE_I) {
				switch(laddr){
					// TODO : différencier changement d'adresse et démarrage
					case(0):
						std::cout << name() <<": RUN" << std::endl;
						run = ((p_wb_slave.DAT_I.read() & 0x1) == 1);
						break;
					case(4):
						std::cout << name() << ": next_address_base modifiée" << std::endl;
						next_address_base = p_wb_slave.DAT_I.read();
						break;
				}
			}
		}
	}
}
}// namespace


