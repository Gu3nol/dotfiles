-- Guénolé Lallement
-- draw-octant
-- VHDL & Logic Synthesis Coursework

library IEEE;

use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

-- Declaration of the entity draw_octant
entity draw_octant is
  port(
    clk, resetx, draw, xbias, disable : in  std_logic;
    xin, yin                          : in  std_logic_vector(11 downto 0);
    done                              : out std_logic;
    x, y                              : out std_logic_vector(11 downto 0)
    );
end entity draw_octant;

-- Declaration of the archietcture draw_octant
architecture comb of draw_octant is

  -- Intern signals
  signal done1                    : std_logic;
  signal x1, y1                   : std_logic_vector(11 downto 0);
  signal xincr, yincr, xnew, ynew : std_logic_vector(11 downto 0);
  signal error                    : std_logic_vector(11 downto 0);
  signal err1, err2               : std_logic_vector(12 downto 0);

  -- Alias
  alias slv is std_logic_vector;
  alias sg is signed;

begin
  done <= done1;  -- we can't read the output done we use a copy done1

  -- Combinational process to generate err1, err2 and done
  C1 : process(error, xincr, yincr, x1, y1, xnew, ynew, resetx, draw)

    -- variable err1_v, err2_v : slv(12 downto 0);

  begin
    -- err1 = |error + yincr|
    err1 <= slv(abs(sg(error) + resize(sg(yincr), 13)));

    -- err2 = |error+yincr - xincr|
    err1 <= slv(abs(sg(error) + resize(sg(yincr), 13) + resize(sg(xincr), 13)));

    -- done : x = xnew and y = ynew and reset = 0 and draw = 0
    if x1 = xnew and y1 = ynew and resetx = '0' and draw = '0' then
      done1 <= '1';
    else
      done1 <= '0';
    end if;
  end process C1;

--  Registered process
  R1 : process(clk)
  begin
    -- WAIT UNTIL clk'event AND clk = '1';
    if rising_edge(clk) then
      if disable = '0' then             -- disable low
        if resetx = '1' then            -- set value to the reset (high)
          error <= (others => '0');
          x     <= xin;
          y     <= yin;
          xincr <= (others => '0');
          yincr <= (others => '0');
          xnew  <= xin;
          ynew  <= yin;
        elsif err1 > err2 or (err1 = err2 and xbias = '0') then
          y1    <= slv(sg(y1) + 1);
          x1    <= slv(sg(x1) + 1);
          error <= slv(sg(error) + sg(yincr) - sg(xincr));
        elsif err1 < err2 or (err1 = err2 and xbias = '1') then
          x1    <= slv(sg(x1) + 1);
          error <= slv(sg(error) + sg(yincr));
        elsif draw = '1' then           -- draw high
          xincr <= slv(sg(xin)-sg(x1));
          yincr <= slv(sg(yin)-sg(y1));
          xnew  <= xin;
          ynew  <= yin;
        elsif done1 = '1' then          -- done high
          null;                         -- no change in input
        end if;
      end if;
    end if;
  end process R1;
end architecture comb;
