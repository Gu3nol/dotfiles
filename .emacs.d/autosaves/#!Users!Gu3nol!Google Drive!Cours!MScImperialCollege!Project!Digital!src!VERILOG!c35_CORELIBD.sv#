// 
// ******************************************************************************
// *                                                                            *
// *                   Copyright (C) 2004-2013, Nangate Inc.                    *
// *                           All rights reserved.                             *
// *                                                                            *
// * Nangate and the Nangate logo are trademarks of Nangate Inc.                *
// *                                                                            *
// * All trademarks, logos, software marks, and trade names (collectively the   *
// * "Marks") in this program are proprietary to Nangate or other respective    *
// * owners that have granted Nangate the right and license to use such Marks.  *
// * You are not permitted to use the Marks without the prior written consent   *
// * of Nangate or such third party that may own the Marks.                     *
// *                                                                            *
// * This file has been provided pursuant to a License Agreement containing     *
// * restrictions on its use. This file contains valuable trade secrets and     *
// * proprietary information of Nangate Inc., and is protected by U.S. and      *
// * international laws and/or treaties.                                        *
// *                                                                            *
// * The copyright notice(s) in this file does not indicate actual or intended  *
// * publication of this file.                                                  *
// *                                                                            *
// *NGLibraryCharacterizer, v2012.06-QR02-SP2-2012-12-07-abr_32 - build 1212291518*
// *                                                                            *
// ******************************************************************************
// 
// 
// Running on du31694l for user Bodo Kaufmann (bka).
// Local time is now Thu, 14 Feb 2013, 00:37:40.
// Main process id is 27079.
// 
// * Default delays
//   * comb. path delay        : 0.0
//   * seq. path delay         : 0.0
//   * delay cells             : 0.0
//   * timing checks           : 0.0
// 
// * NTC Setup
//   * Export NTC sections     : true
//   * Combine setup / hold    : true
//   * Combine recovery/removal: true
// 
// * Extras
//   * Export `celldefine      : false
//   * Export `timescale       : -
// 


`timescale 1ns/1ps
`celldefine

`define NTC
`define RECREM

module AND2X1 (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X2 (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X3 (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X4 (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X6 (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND2X8 (A, B, Q);
  input A;
  input B;
  output Q;

  and(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_274, C);
  and(i_274, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_325, C);
  and(i_325, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_238, C);
  and(i_238, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_232, C);
  and(i_232, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X6 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_340, C);
  and(i_340, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AND3X8 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  and(Q, i_316, C);
  and(i_316, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X1 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_314);
  or(i_314, i_315, B1);
  and(i_315, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X2 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_338);
  or(i_338, i_339, B1);
  and(i_339, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X3 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_410);
  or(i_410, i_411, B1);
  and(i_411, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X4 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_416);
  or(i_416, i_417, B1);
  and(i_417, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X6 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_263);
  or(i_263, i_264, B1);
  and(i_264, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI21X8 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_242);
  or(i_242, i_243, B1);
  and(i_243, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X1 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_222);
  or(i_222, i_223, i_224);
  and(i_223, A1, A2);
  and(i_224, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X2 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_303);
  or(i_303, i_304, i_305);
  and(i_304, A1, A2);
  and(i_305, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X3 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_180);
  or(i_180, i_181, i_182);
  and(i_181, A1, A2);
  and(i_182, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X4 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_300);
  or(i_300, i_301, i_302);
  and(i_301, A1, A2);
  and(i_302, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X6 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_270);
  or(i_270, i_271, i_272);
  and(i_271, A1, A2);
  and(i_272, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI22X8 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_198);
  or(i_198, i_199, i_200);
  and(i_199, A1, A2);
  and(i_200, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X1 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_207);
  or(i_207, i_208, B1);
  and(i_208, i_209, A3);
  and(i_209, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X2 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_186);
  or(i_186, i_187, B1);
  and(i_187, i_188, A3);
  and(i_188, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X3 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_180);
  or(i_180, i_181, B1);
  and(i_181, i_182, A3);
  and(i_182, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X4 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_384);
  or(i_384, i_385, B1);
  and(i_385, i_386, A3);
  and(i_386, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X6 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_303);
  or(i_303, i_304, B1);
  and(i_304, i_305, A3);
  and(i_305, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI31X8 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_183);
  or(i_183, i_184, B1);
  and(i_184, i_185, A3);
  and(i_185, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X1 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_241);
  or(i_241, i_242, i_244);
  and(i_242, i_243, A3);
  and(i_243, A1, A2);
  and(i_244, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X2 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_121);
  or(i_121, i_122, i_124);
  and(i_122, i_123, A3);
  and(i_123, A1, A2);
  and(i_124, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X3 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_172);
  or(i_172, i_173, i_175);
  and(i_173, i_174, A3);
  and(i_174, A1, A2);
  and(i_175, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X4 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_100);
  or(i_100, i_101, i_103);
  and(i_101, i_102, A3);
  and(i_102, A1, A2);
  and(i_103, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X6 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_133);
  or(i_133, i_134, i_136);
  and(i_134, i_135, A3);
  and(i_135, A1, A2);
  and(i_136, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI32X8 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_280);
  or(i_280, i_281, i_283);
  and(i_281, i_282, A3);
  and(i_282, A1, A2);
  and(i_283, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X1 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_261);
  or(i_261, i_262, C1);
  or(i_262, i_263, B1);
  and(i_263, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X2 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_354);
  or(i_354, i_355, C1);
  or(i_355, i_356, B1);
  and(i_356, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X3 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_303);
  or(i_303, i_304, C1);
  or(i_304, i_305, B1);
  and(i_305, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X4 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_168);
  or(i_168, i_169, C1);
  or(i_169, i_170, B1);
  and(i_170, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X6 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_240);
  or(i_240, i_241, C1);
  or(i_241, i_242, B1);
  and(i_242, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI211X8 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_174);
  or(i_174, i_175, C1);
  or(i_175, i_176, B1);
  and(i_176, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X1 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_94);
  or(i_94, i_95, C1);
  or(i_95, i_96, i_97);
  and(i_96, A1, A2);
  and(i_97, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X2 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_112);
  or(i_112, i_113, C1);
  or(i_113, i_114, i_115);
  and(i_114, A1, A2);
  and(i_115, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X3 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_94);
  or(i_94, i_95, C1);
  or(i_95, i_96, i_97);
  and(i_96, A1, A2);
  and(i_97, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X4 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_136);
  or(i_136, i_137, C1);
  or(i_137, i_138, i_139);
  and(i_138, A1, A2);
  and(i_139, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X6 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_202);
  or(i_202, i_203, C1);
  or(i_203, i_204, i_205);
  and(i_204, A1, A2);
  and(i_205, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI221X8 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_184);
  or(i_184, i_185, C1);
  or(i_185, i_186, i_187);
  and(i_186, A1, A2);
  and(i_187, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X1 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_217);
  or(i_217, i_218, C1);
  or(i_218, i_219, B1);
  and(i_219, i_220, A3);
  and(i_220, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X2 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_298);
  or(i_298, i_299, C1);
  or(i_299, i_300, B1);
  and(i_300, i_301, A3);
  and(i_301, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X3 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_124);
  or(i_124, i_125, C1);
  or(i_125, i_126, B1);
  and(i_126, i_127, A3);
  and(i_127, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X4 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_229);
  or(i_229, i_230, C1);
  or(i_230, i_231, B1);
  and(i_231, i_232, A3);
  and(i_232, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X6 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_94);
  or(i_94, i_95, C1);
  or(i_95, i_96, B1);
  and(i_96, i_97, A3);
  and(i_97, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AOI311X8 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_226);
  or(i_226, i_227, C1);
  or(i_227, i_228, B1);
  and(i_228, i_229, A3);
  and(i_229, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X1 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_439, B1);
  and(i_439, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X2 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_436, B1);
  and(i_436, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X3 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_268, B1);
  and(i_268, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X4 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_319, B1);
  and(i_319, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X6 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_226, B1);
  and(i_226, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO21X8 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  or(Q, i_232, B1);
  and(i_232, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X1 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_200, i_201);
  and(i_200, A1, A2);
  and(i_201, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X2 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_272, i_273);
  and(i_272, A1, A2);
  and(i_273, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X3 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_164, i_165);
  and(i_164, A1, A2);
  and(i_165, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X4 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_206, i_207);
  and(i_206, A1, A2);
  and(i_207, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X6 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_164, i_165);
  and(i_164, A1, A2);
  and(i_165, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO22X8 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  or(Q, i_368, i_369);
  and(i_368, A1, A2);
  and(i_369, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X1 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_287, B1);
  and(i_287, i_288, A3);
  and(i_288, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X2 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_284, B1);
  and(i_284, i_285, A3);
  and(i_285, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X3 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_254, B1);
  and(i_254, i_255, A3);
  and(i_255, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X4 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_182, B1);
  and(i_182, i_183, A3);
  and(i_183, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X6 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_191, B1);
  and(i_191, i_192, A3);
  and(i_192, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO31X8 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  or(Q, i_170, B1);
  and(i_170, i_171, A3);
  and(i_171, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X1 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_126, i_128);
  and(i_126, i_127, A3);
  and(i_127, A1, A2);
  and(i_128, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X2 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_189, i_191);
  and(i_189, i_190, A3);
  and(i_190, A1, A2);
  and(i_191, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X3 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_99, i_101);
  and(i_99, i_100, A3);
  and(i_100, A1, A2);
  and(i_101, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X4 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_219, i_221);
  and(i_219, i_220, A3);
  and(i_220, A1, A2);
  and(i_221, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X6 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_150, i_152);
  and(i_150, i_151, A3);
  and(i_151, A1, A2);
  and(i_152, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO32X8 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  or(Q, i_78, i_80);
  and(i_78, i_79, A3);
  and(i_79, A1, A2);
  and(i_80, B1, B2);

  specify
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X1 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_287, C1);
  or(i_287, i_288, B1);
  and(i_288, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X2 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_338, C1);
  or(i_338, i_339, B1);
  and(i_339, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X3 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_245, C1);
  or(i_245, i_246, B1);
  and(i_246, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X4 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_167, C1);
  or(i_167, i_168, B1);
  and(i_168, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X6 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_152, C1);
  or(i_152, i_153, B1);
  and(i_153, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO211X8 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  or(Q, i_287, C1);
  or(i_287, i_288, B1);
  and(i_288, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X1 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_111, C1);
  or(i_111, i_112, i_113);
  and(i_112, A1, A2);
  and(i_113, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X2 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_258, C1);
  or(i_258, i_259, i_260);
  and(i_259, A1, A2);
  and(i_260, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X3 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_72, C1);
  or(i_72, i_73, i_74);
  and(i_73, A1, A2);
  and(i_74, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X4 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_90, C1);
  or(i_90, i_91, i_92);
  and(i_91, A1, A2);
  and(i_92, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X6 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_72, C1);
  or(i_72, i_73, i_74);
  and(i_73, A1, A2);
  and(i_74, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module AO221X8 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  or(Q, i_162, C1);
  or(i_162, i_163, i_164);
  and(i_163, A1, A2);
  and(i_164, B1, B2);

  specify
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (C1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFEX2 (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX4 (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX6 (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX8 (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX10 (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFEX12 (A, E, Q);
  input A;
  input E;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  not(Q_enable, E);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (E => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX2 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX4 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX6 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX8 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX10 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX12 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFTX16 (A, EN, Q);
  input A;
  input EN;
  output Q;

  bufif0(Q, Q_in, Q_enable);
  buf(Q_enable, EN);
  buf(Q_in, A);

  specify
    (A => Q) = (0.0, 0.0);
    (EN => Q) = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
  endspecify

endmodule

module BUFX2 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX3 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX4 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX6 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX8 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX12 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX16 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX24 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module BUFX32 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX2 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX3 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX4 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX6 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX8 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX10 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX12 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX16 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX24 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKBUFX32 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX1 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX2 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX3 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX4 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX6 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX8 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX10 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX12 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX16 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX24 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module CLKINVX32 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

primitive \seq_DFCPSX1  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX1 (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX1 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_83, i_84);
    not(i_83, IQ);
    not(i_84, i_85);
    and(i_85, i_86, i_87);
    not(i_86, SN_d);
    not(i_87, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_88, i_89);
    and(i_88, SE_d, SI_d);
    and(i_89, i_90, D_d);
    not(i_90, SE_d);

    // Delayed data/reference logic
    and(id_57, SN_d, RN_d);
    and(id_58, id_57, i_95);
    not(i_95, SE_d);
    and(id_59, id_57, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_57, id_57, 1'b1);
      ng_xbuf(xid_58, id_58, 1'b1);
      ng_xbuf(xid_59, id_59, 1'b1);
    `endif
  `else
    \seq_DFCPSX1 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_83, i_84);
    not(i_83, IQ);
    not(i_84, i_85);
    and(i_85, i_86, i_87);
    not(i_86, SN);
    not(i_87, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_88, i_89);
    and(i_88, SE, SI);
    and(i_89, i_90, D);
    not(i_90, SE);

    // Delayed data/reference logic
    and(id_54, SN, RN);
    and(id_55, id_54, i_94);
    not(i_94, SE);
    and(id_56, id_54, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_54, id_54, 1'b1);
      ng_xbuf(xid_55, id_55, 1'b1);
      ng_xbuf(xid_56, id_56, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_58), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_58), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_59), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_59), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_57), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_57), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_55), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_55), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_56), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_56), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_54), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_54), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX2  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX2 (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX2 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN_d);
    not(i_30, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE_d, SI_d);
    and(i_32, i_33, D_d);
    not(i_33, SE_d);

    // Delayed data/reference logic
    and(id_33, SN_d, RN_d);
    and(id_34, id_33, i_38);
    not(i_38, SE_d);
    and(id_35, id_33, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_DFCPSX2 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN);
    not(i_30, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE, SI);
    and(i_32, i_33, D);
    not(i_33, SE);

    // Delayed data/reference logic
    and(id_30, SN, RN);
    and(id_31, id_30, i_37);
    not(i_37, SE);
    and(id_32, id_30, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
      ng_xbuf(xid_31, id_31, 1'b1);
      ng_xbuf(xid_32, id_32, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_35), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_35), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX3  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX3 (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX3 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_50, i_51);
    not(i_50, IQ);
    not(i_51, i_52);
    and(i_52, i_53, i_54);
    not(i_53, SN_d);
    not(i_54, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_55, i_56);
    and(i_55, SE_d, SI_d);
    and(i_56, i_57, D_d);
    not(i_57, SE_d);

    // Delayed data/reference logic
    and(id_45, SN_d, RN_d);
    and(id_46, id_45, i_62);
    not(i_62, SE_d);
    and(id_47, id_45, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_45, id_45, 1'b1);
      ng_xbuf(xid_46, id_46, 1'b1);
      ng_xbuf(xid_47, id_47, 1'b1);
    `endif
  `else
    \seq_DFCPSX3 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_50, i_51);
    not(i_50, IQ);
    not(i_51, i_52);
    and(i_52, i_53, i_54);
    not(i_53, SN);
    not(i_54, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_55, i_56);
    and(i_55, SE, SI);
    and(i_56, i_57, D);
    not(i_57, SE);

    // Delayed data/reference logic
    and(id_42, SN, RN);
    and(id_43, id_42, i_61);
    not(i_61, SE);
    and(id_44, id_42, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_42, id_42, 1'b1);
      ng_xbuf(xid_43, id_43, 1'b1);
      ng_xbuf(xid_44, id_44, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_46), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_46), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_47), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_47), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_45), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_43), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_44), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_42), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX4  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX4 (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX4 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_44, i_45);
    not(i_44, IQ);
    not(i_45, i_46);
    and(i_46, i_47, i_48);
    not(i_47, SN_d);
    not(i_48, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_49, i_50);
    and(i_49, SE_d, SI_d);
    and(i_50, i_51, D_d);
    not(i_51, SE_d);

    // Delayed data/reference logic
    and(id_39, SN_d, RN_d);
    and(id_40, id_39, i_56);
    not(i_56, SE_d);
    and(id_41, id_39, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_39, id_39, 1'b1);
      ng_xbuf(xid_40, id_40, 1'b1);
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    \seq_DFCPSX4 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_44, i_45);
    not(i_44, IQ);
    not(i_45, i_46);
    and(i_46, i_47, i_48);
    not(i_47, SN);
    not(i_48, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_49, i_50);
    and(i_49, SE, SI);
    and(i_50, i_51, D);
    not(i_51, SE);

    // Delayed data/reference logic
    and(id_36, SN, RN);
    and(id_37, id_36, i_55);
    not(i_55, SE);
    and(id_38, id_36, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
      ng_xbuf(xid_38, id_38, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_41), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPSX6  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPSX6 (D, RN, SE, SI, SN, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPSX6 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN_d);
    not(i_30, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE_d, SI_d);
    and(i_32, i_33, D_d);
    not(i_33, SE_d);

    // Delayed data/reference logic
    and(id_47, SN_d, RN_d);
    and(id_48, id_47, i_38);
    not(i_38, SE_d);
    and(id_49, id_47, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_47, id_47, 1'b1);
      ng_xbuf(xid_48, id_48, 1'b1);
      ng_xbuf(xid_49, id_49, 1'b1);
    `endif
  `else
    \seq_DFCPSX6 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_26, i_27);
    not(i_26, IQ);
    not(i_27, i_28);
    and(i_28, i_29, i_30);
    not(i_29, SN);
    not(i_30, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_31, i_32);
    and(i_31, SE, SI);
    and(i_32, i_33, D);
    not(i_33, SE);

    // Delayed data/reference logic
    and(id_44, SN, RN);
    and(id_45, id_44, i_37);
    not(i_37, SE);
    and(id_46, id_44, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_44, id_44, 1'b1);
      ng_xbuf(xid_45, id_45, 1'b1);
      ng_xbuf(xid_46, id_46, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_48), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_48), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_49), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_49), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_47), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_47), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_45), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_45), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_46), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_46), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_44), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_44), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX1  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX1 (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX1 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_73, i_74);
    not(i_73, IQ);
    not(i_74, i_75);
    and(i_75, i_76, i_77);
    not(i_76, SN_d);
    not(i_77, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_53, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_53, id_53, 1'b1);
    `endif
  `else
    \seq_DFCPX1 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_73, i_74);
    not(i_73, IQ);
    not(i_74, i_75);
    and(i_75, i_76, i_77);
    not(i_76, SN);
    not(i_77, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_52, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_52, id_52, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_53), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_53), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_53), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_52), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_52), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_52), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX2  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX2 (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX2 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN_d);
    not(i_14, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_25, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_25, id_25, 1'b1);
    `endif
  `else
    \seq_DFCPX2 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN);
    not(i_14, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_24, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_24, id_24, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_25), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_25), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_25), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_25), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_24), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_24), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_24), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_24), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX3  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX3 (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX3 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN_d);
    not(i_14, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCPX3 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN);
    not(i_14, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX4  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX4 (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX4 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN_d);
    not(i_14, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCPX4 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_10, i_11);
    not(i_10, IQ);
    not(i_11, i_12);
    and(i_12, i_13, i_14);
    not(i_13, SN);
    not(i_14, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCPX6  (IQ, SN, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           ?           0           r           ?       : ? :           0;
           ?           1           1           r           ?       : ? :           1;
           1           ?           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           1           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCPX6 (D, RN, SN, CP, Q, QN);
  input D;
  input RN;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_DFCPX6 (IQ, SN_d, RN_d, nextstate, CP_d, NOTIFIER);
    and(IQN, i_52, i_53);
    not(i_52, IQ);
    not(i_53, i_54);
    and(i_54, i_55, i_56);
    not(i_55, SN_d);
    not(i_56, RN_d);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_41, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    \seq_DFCPX6 (IQ, SN, RN, nextstate, CP, NOTIFIER);
    and(IQN, i_52, i_53);
    not(i_52, IQ);
    not(i_53, i_54);
    and(i_54, i_55, i_56);
    not(i_55, SN);
    not(i_56, RN);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_40, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_40, id_40, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_41), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_41), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_41), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_40), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_40), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX1  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX1 (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX1 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_100, i_101);
    and(i_100, SE_d, SI_d);
    and(i_101, i_102, D_d);
    not(i_102, SE_d);

    // Delayed data/reference logic
    buf(id_33, RN_d);
    and(id_34, id_33, i_107);
    not(i_107, SE_d);
    and(id_35, id_33, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_DFCSX1 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_100, i_101);
    and(i_100, SE, SI);
    and(i_101, i_102, D);
    not(i_102, SE);

    // Delayed data/reference logic
    buf(id_30, RN);
    and(id_31, id_30, i_106);
    not(i_106, SE);
    and(id_32, id_30, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
      ng_xbuf(xid_31, id_31, 1'b1);
      ng_xbuf(xid_32, id_32, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_35), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_35), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX2  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX2 (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX2 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_33, RN_d);
    and(id_34, id_33, i_23);
    not(i_23, SE_d);
    and(id_35, id_33, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_DFCSX2 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_30, RN);
    and(id_31, id_30, i_22);
    not(i_22, SE);
    and(id_32, id_30, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
      ng_xbuf(xid_31, id_31, 1'b1);
      ng_xbuf(xid_32, id_32, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_35), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_35), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX3  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX3 (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX3 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_112, i_113);
    and(i_112, SE_d, SI_d);
    and(i_113, i_114, D_d);
    not(i_114, SE_d);

    // Delayed data/reference logic
    buf(id_75, RN_d);
    and(id_76, id_75, i_119);
    not(i_119, SE_d);
    and(id_77, id_75, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_75, id_75, 1'b1);
      ng_xbuf(xid_76, id_76, 1'b1);
      ng_xbuf(xid_77, id_77, 1'b1);
    `endif
  `else
    \seq_DFCSX3 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_112, i_113);
    and(i_112, SE, SI);
    and(i_113, i_114, D);
    not(i_114, SE);

    // Delayed data/reference logic
    buf(id_72, RN);
    and(id_73, id_72, i_118);
    not(i_118, SE);
    and(id_74, id_72, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_72, id_72, 1'b1);
      ng_xbuf(xid_73, id_73, 1'b1);
      ng_xbuf(xid_74, id_74, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_76), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_76), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_77), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_77), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_75), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_75), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_73), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_73), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_74), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_74), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_72), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_72), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX4  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX4 (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX4 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_34, i_35);
    and(i_34, SE_d, SI_d);
    and(i_35, i_36, D_d);
    not(i_36, SE_d);

    // Delayed data/reference logic
    buf(id_33, RN_d);
    and(id_34, id_33, i_41);
    not(i_41, SE_d);
    and(id_35, id_33, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_33, id_33, 1'b1);
      ng_xbuf(xid_34, id_34, 1'b1);
      ng_xbuf(xid_35, id_35, 1'b1);
    `endif
  `else
    \seq_DFCSX4 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_34, i_35);
    and(i_34, SE, SI);
    and(i_35, i_36, D);
    not(i_36, SE);

    // Delayed data/reference logic
    buf(id_30, RN);
    and(id_31, id_30, i_40);
    not(i_40, SE);
    and(id_32, id_30, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
      ng_xbuf(xid_31, id_31, 1'b1);
      ng_xbuf(xid_32, id_32, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_34), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_34), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_35), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_35), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_33), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_32), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCSX6  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCSX6 (D, RN, SE, SI, CP, Q, QN);
  input D;
  input RN;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCSX6 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_34, i_35);
    and(i_34, SE_d, SI_d);
    and(i_35, i_36, D_d);
    not(i_36, SE_d);

    // Delayed data/reference logic
    buf(id_39, RN_d);
    and(id_40, id_39, i_41);
    not(i_41, SE_d);
    and(id_41, id_39, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_39, id_39, 1'b1);
      ng_xbuf(xid_40, id_40, 1'b1);
      ng_xbuf(xid_41, id_41, 1'b1);
    `endif
  `else
    \seq_DFCSX6 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_34, i_35);
    and(i_34, SE, SI);
    and(i_35, i_36, D);
    not(i_36, SE);

    // Delayed data/reference logic
    buf(id_36, RN);
    and(id_37, id_36, i_40);
    not(i_40, SE);
    and(id_38, id_36, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_36, id_36, 1'b1);
      ng_xbuf(xid_37, id_37, 1'b1);
      ng_xbuf(xid_38, id_38, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_40), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_40), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_41), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_41), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_39), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_37), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_38), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_36), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX1  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX1 (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX1 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_19, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_19, id_19, 1'b1);
    `endif
  `else
    \seq_DFCX1 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_18, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_18, id_18, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_19), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_19), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_19), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_19), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_18), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_18), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX2  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX2 (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX2 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_DFCX2 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX3  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX3 (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX3 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFCX3 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX4  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX4 (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX4 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_29, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    \seq_DFCX4 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_28, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_28, id_28, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_29), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_29), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_29), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_29), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_28), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_28), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFCX6  (IQ, RN, nextstate, CP, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           ?           0           r           ?       : ? :           0;
           1           1           r           ?       : ? :           1;
           ?           0           *           ?       : 0 :           0; // reduce pessimism
           1           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFCX6 (D, RN, CP, Q, QN);
  input D;
  input RN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_DFCX6 (IQ, RN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_31, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_31, id_31, 1'b1);
    `endif
  `else
    \seq_DFCX6 (IQ, RN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_30, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_30, id_30, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge CP, 0.0, 0.0, NOTIFIER, , ,RN_di, CP_d);
      `else
        $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_31), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_31), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_31), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_31), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_30), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_30), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_30), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX1  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX1 (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX1 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_27, SN_d);
    and(id_28, id_27, i_23);
    not(i_23, SE_d);
    and(id_29, id_27, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_27, id_27, 1'b1);
      ng_xbuf(xid_28, id_28, 1'b1);
      ng_xbuf(xid_29, id_29, 1'b1);
    `endif
  `else
    \seq_DFPSX1 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_24, SN);
    and(id_25, id_24, i_22);
    not(i_22, SE);
    and(id_26, id_24, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_24, id_24, 1'b1);
      ng_xbuf(xid_25, id_25, 1'b1);
      ng_xbuf(xid_26, id_26, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_28), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_28), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_29), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_29), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_27), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_27), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_25), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_25), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_26), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_26), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_24), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_24), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX2  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX2 (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX2 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_15, SN_d);
    and(id_16, id_15, i_23);
    not(i_23, SE_d);
    and(id_17, id_15, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_15, id_15, 1'b1);
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFPSX2 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_12, SN);
    and(id_13, id_12, i_22);
    not(i_22, SE);
    and(id_14, id_12, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_12, id_12, 1'b1);
      ng_xbuf(xid_13, id_13, 1'b1);
      ng_xbuf(xid_14, id_14, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_15), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_13), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_12), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPSX3  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPSX3 (D, SE, SI, SN, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPSX3 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE_d, SI_d);
    and(i_17, i_18, D_d);
    not(i_18, SE_d);

    // Delayed data/reference logic
    buf(id_21, SN_d);
    and(id_22, id_21, i_23);
    not(i_23, SE_d);
    and(id_23, id_21, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_21, id_21, 1'b1);
      ng_xbuf(xid_22, id_22, 1'b1);
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_DFPSX3 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_16, i_17);
    and(i_16, SE, SI);
    and(i_17, i_18, D);
    not(i_18, SE);

    // Delayed data/reference logic
    buf(id_18, SN);
    and(id_19, id_18, i_22);
    not(i_22, SE);
    and(id_20, id_18, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_18, id_18, 1'b1);
      ng_xbuf(xid_19, id_19, 1'b1);
      ng_xbuf(xid_20, id_20, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b0) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1) && (SE == 1'b1) && (SI == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_23), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_21), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_19), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_18), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX1  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX1 (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX1 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_25, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_25, id_25, 1'b1);
    `endif
  `else
    \seq_DFPX1 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_24, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_24, id_24, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_25), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_25), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_25), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_25), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_24), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_24), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_24), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_24), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX2  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX2 (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX2 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_DFPX2 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX3  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX3 (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX3 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFPX3 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX4  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX4 (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX4 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFPX4 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFPX6  (IQ, SN, nextstate, CP, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          CP    NOTIFIER     : @IQ :          IQ
           1           0           r           ?       : ? :           0;
           ?           1           r           ?       : ? :           1;
           1           0           *           ?       : 0 :           0; // reduce pessimism
           ?           1           *           ?       : 1 :           1; // reduce pessimism
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFPX6 (D, SN, CP, Q, QN);
  input D;
  input SN;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_DFPX6 (IQ, SN_d, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFPX6 (IQ, SN, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    if((CP == 1'b0) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b0) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((CP == 1'b1) && (D == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge CP, 0.0, 0.0, NOTIFIER, , ,SN_di, CP_d);
      `else
        $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge CP &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(posedge CP, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge CP, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge CP &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX1  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX1 (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX1 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFSX1 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX2  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX2 (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX2 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_10, SE_d);
    buf(id_11, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_DFSX2 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_8, SE);
    buf(id_9, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_8, id_8, 1'b1);
      ng_xbuf(xid_9, id_9, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_11), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_11), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_8), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_8), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_9), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX3  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX3 (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX3 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_16, SE_d);
    buf(id_17, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFSX3 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_14, SE);
    buf(id_15, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_14, id_14, 1'b1);
      ng_xbuf(xid_15, id_15, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_14), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_15), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_15), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX4  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX4 (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX4 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_22, SE_d);
    buf(id_23, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_DFSX4 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_20, SE);
    buf(id_21, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_20, id_20, 1'b1);
      ng_xbuf(xid_21, id_21, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_23), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_23), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_20), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_20), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_21), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_21), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFSX6  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFSX6 (D, SE, SI, CP, Q, QN);
  input D;
  input SE;
  input SI;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFSX6 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE_d, SI_d);
    and(i_13, i_14, D_d);
    not(i_14, SE_d);

    // Delayed data/reference logic
    not(id_16, SE_d);
    buf(id_17, SE_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_DFSX6 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    or(nextstate, i_12, i_13);
    and(i_12, SE, SI);
    and(i_13, i_14, D);
    not(i_14, SE);

    // Delayed data/reference logic
    not(id_14, SE);
    buf(id_15, SE);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_14, id_14, 1'b1);
      ng_xbuf(xid_15, id_15, 1'b1);
    `endif
  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP &&& (xid_17), negedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP &&& (xid_17), posedge SI, 0.0, 0.0, NOTIFIER, , ,CP_d, SI_d);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER, , ,CP_d, SE_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP &&& (xid_14), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_14), posedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_15), negedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP &&& (xid_15), posedge SI, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX1  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX1 (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX1 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX1 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX2  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX2 (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX2 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX2 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX3  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX3 (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX3 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX3 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX4  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX4 (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX4 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX4 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_DFX6  (IQ, nextstate, CP, NOTIFIER);
  output IQ;
  input nextstate;
  input CP;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          CP    NOTIFIER     : @IQ :          IQ
           0           r           ?       : ? :           0;
           1           r           ?       : ? :           1;
           0           *           ?       : 0 :           0; // reduce pessimism
           1           *           ?       : 1 :           1; // reduce pessimism
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           n           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module DFX6 (D, CP, Q, QN);
  input D;
  input CP;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_DFX6 (IQ, nextstate, CP_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_DFX6 (IQ, nextstate, CP, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (posedge CP => (Q +: D)) = (0.1, 0.1);
    (posedge CP => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER, , ,CP_d, D_d);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CP, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CP, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge CP, 0.0, 0, NOTIFIER);
      $width(posedge CP, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

module DLY1X1 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY2X1 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY3X1 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module DLY4X1 (A, Q);
  input A;
  output Q;

  buf(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module FAX1 (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_423, i_426);
  or(i_423, i_424, i_425);
  and(i_424, A, B);
  and(i_425, A, CI);
  and(i_426, B, CI);
  not(SUM, i_431);
  or(i_431, i_432, i_438);
  and(i_432, i_433, CI);
  not(i_433, i_434);
  or(i_434, i_435, i_436);
  and(i_435, A, B);
  not(i_436, i_437);
  or(i_437, A, B);
  not(i_438, i_439);
  or(i_439, i_440, CI);
  not(i_440, i_441);
  or(i_441, i_442, i_443);
  and(i_442, A, B);
  not(i_443, i_444);
  or(i_444, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX2 (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_420, i_423);
  or(i_420, i_421, i_422);
  and(i_421, A, B);
  and(i_422, A, CI);
  and(i_423, B, CI);
  not(SUM, i_428);
  or(i_428, i_429, i_435);
  and(i_429, i_430, CI);
  not(i_430, i_431);
  or(i_431, i_432, i_433);
  and(i_432, A, B);
  not(i_433, i_434);
  or(i_434, A, B);
  not(i_435, i_436);
  or(i_436, i_437, CI);
  not(i_437, i_438);
  or(i_438, i_439, i_440);
  and(i_439, A, B);
  not(i_440, i_441);
  or(i_441, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX3 (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_501, i_504);
  or(i_501, i_502, i_503);
  and(i_502, A, B);
  and(i_503, A, CI);
  and(i_504, B, CI);
  not(SUM, i_509);
  or(i_509, i_510, i_516);
  and(i_510, i_511, CI);
  not(i_511, i_512);
  or(i_512, i_513, i_514);
  and(i_513, A, B);
  not(i_514, i_515);
  or(i_515, A, B);
  not(i_516, i_517);
  or(i_517, i_518, CI);
  not(i_518, i_519);
  or(i_519, i_520, i_521);
  and(i_520, A, B);
  not(i_521, i_522);
  or(i_522, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX4 (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_546, i_549);
  or(i_546, i_547, i_548);
  and(i_547, A, B);
  and(i_548, A, CI);
  and(i_549, B, CI);
  not(SUM, i_554);
  or(i_554, i_555, i_561);
  and(i_555, i_556, CI);
  not(i_556, i_557);
  or(i_557, i_558, i_559);
  and(i_558, A, B);
  not(i_559, i_560);
  or(i_560, A, B);
  not(i_561, i_562);
  or(i_562, i_563, CI);
  not(i_563, i_564);
  or(i_564, i_565, i_566);
  and(i_565, A, B);
  not(i_566, i_567);
  or(i_567, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX6 (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_459, i_462);
  or(i_459, i_460, i_461);
  and(i_460, A, B);
  and(i_461, A, CI);
  and(i_462, B, CI);
  not(SUM, i_467);
  or(i_467, i_468, i_474);
  and(i_468, i_469, CI);
  not(i_469, i_470);
  or(i_470, i_471, i_472);
  and(i_471, A, B);
  not(i_472, i_473);
  or(i_473, A, B);
  not(i_474, i_475);
  or(i_475, i_476, CI);
  not(i_476, i_477);
  or(i_477, i_478, i_479);
  and(i_478, A, B);
  not(i_479, i_480);
  or(i_480, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module FAX8 (A, B, CI, CO, SUM);
  input A;
  input B;
  input CI;
  output CO;
  output SUM;

  or(CO, i_432, i_435);
  or(i_432, i_433, i_434);
  and(i_433, A, B);
  and(i_434, A, CI);
  and(i_435, B, CI);
  not(SUM, i_440);
  or(i_440, i_441, i_447);
  and(i_441, i_442, CI);
  not(i_442, i_443);
  or(i_443, i_444, i_445);
  and(i_444, A, B);
  not(i_445, i_446);
  or(i_446, A, B);
  not(i_447, i_448);
  or(i_448, i_449, CI);
  not(i_449, i_450);
  or(i_450, i_451, i_452);
  and(i_451, A, B);
  not(i_452, i_453);
  or(i_453, A, B);

  specify
    if((B == 1'b0) && (CI == 1'b1)) (A => CO) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => CO) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => CO) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => CO) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => CO) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => CO) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b0) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1) && (CI == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (CI == 1'b1)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (CI => SUM) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (CI => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX1 (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_478);
  or(i_478, i_479, i_480);
  and(i_479, A, B);
  not(i_480, i_481);
  or(i_481, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX2 (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_358);
  or(i_358, i_359, i_360);
  and(i_359, A, B);
  not(i_360, i_361);
  or(i_361, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX3 (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_334);
  or(i_334, i_335, i_336);
  and(i_335, A, B);
  not(i_336, i_337);
  or(i_337, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX4 (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_481);
  or(i_481, i_482, i_483);
  and(i_482, A, B);
  not(i_483, i_484);
  or(i_484, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module HAX6 (A, B, CO, SUM);
  input A;
  input B;
  output CO;
  output SUM;

  and(CO, A, B);
  not(SUM, i_559);
  or(i_559, i_560, i_561);
  and(i_560, A, B);
  not(i_561, i_562);
  or(i_562, A, B);

  specify
    (A => CO) = (0.0, 0.0);
    (B => CO) = (0.0, 0.0);
    if((B == 1'b0)) (A => SUM) = (0.0, 0.0);
    if((B == 1'b1)) (A => SUM) = (0.0, 0.0);
    if((A == 1'b0)) (B => SUM) = (0.0, 0.0);
    if((A == 1'b1)) (B => SUM) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_296);
  or(i_296, i_297, i_300);
  or(i_297, i_298, i_299);
  and(i_298, B, A);
  and(i_299, C, B);
  and(i_300, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_326);
  or(i_326, i_327, i_330);
  or(i_327, i_328, i_329);
  and(i_328, B, A);
  and(i_329, C, B);
  and(i_330, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_302);
  or(i_302, i_303, i_306);
  or(i_303, i_304, i_305);
  and(i_304, B, A);
  and(i_305, C, B);
  and(i_306, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMAJ3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_398);
  or(i_398, i_399, i_402);
  or(i_399, i_400, i_401);
  and(i_400, B, A);
  and(i_401, C, B);
  and(i_402, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X1 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_322);
  or(i_322, i_323, i_325);
  and(i_323, A, i_324);
  not(i_324, S);
  and(i_325, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X2 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_394);
  or(i_394, i_395, i_397);
  and(i_395, A, i_396);
  not(i_396, S);
  and(i_397, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X3 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_226);
  or(i_226, i_227, i_229);
  and(i_227, A, i_228);
  not(i_228, S);
  and(i_229, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X4 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_247);
  or(i_247, i_248, i_250);
  and(i_248, A, i_249);
  not(i_249, S);
  and(i_250, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X6 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_424);
  or(i_424, i_425, i_427);
  and(i_425, A, i_426);
  not(i_426, S);
  and(i_427, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX2X8 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  not(Q, i_427);
  or(i_427, i_428, i_430);
  and(i_428, A, i_429);
  not(i_429, S);
  and(i_430, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X1 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_100);
  or(i_100, i_101, i_109);
  or(i_101, i_102, i_106);
  and(i_102, i_103, i_105);
  and(i_103, A, i_104);
  not(i_104, S1);
  not(i_105, S0);
  and(i_106, i_107, S0);
  and(i_107, B, i_108);
  not(i_108, S1);
  and(i_109, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X2 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_166);
  or(i_166, i_167, i_175);
  or(i_167, i_168, i_172);
  and(i_168, i_169, i_171);
  and(i_169, A, i_170);
  not(i_170, S1);
  not(i_171, S0);
  and(i_172, i_173, S0);
  and(i_173, B, i_174);
  not(i_174, S1);
  and(i_175, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X3 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_181);
  or(i_181, i_182, i_190);
  or(i_182, i_183, i_187);
  and(i_183, i_184, i_186);
  and(i_184, A, i_185);
  not(i_185, S1);
  not(i_186, S0);
  and(i_187, i_188, S0);
  and(i_188, B, i_189);
  not(i_189, S1);
  and(i_190, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X4 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_262);
  or(i_262, i_263, i_271);
  or(i_263, i_264, i_268);
  and(i_264, i_265, i_267);
  and(i_265, A, i_266);
  not(i_266, S1);
  not(i_267, S0);
  and(i_268, i_269, S0);
  and(i_269, B, i_270);
  not(i_270, S1);
  and(i_271, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X6 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_88);
  or(i_88, i_89, i_97);
  or(i_89, i_90, i_94);
  and(i_90, i_91, i_93);
  and(i_91, A, i_92);
  not(i_92, S1);
  not(i_93, S0);
  and(i_94, i_95, S0);
  and(i_95, B, i_96);
  not(i_96, S1);
  and(i_97, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX3X8 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  not(Q, i_193);
  or(i_193, i_194, i_202);
  or(i_194, i_195, i_199);
  and(i_195, i_196, i_198);
  and(i_196, A, i_197);
  not(i_197, S1);
  not(i_198, S0);
  and(i_199, i_200, S0);
  and(i_200, B, i_201);
  not(i_201, S1);
  and(i_202, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X1 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_168);
  or(i_168, i_169, i_180);
  or(i_169, i_170, i_178);
  or(i_170, i_171, i_175);
  and(i_171, i_172, i_174);
  and(i_172, A, i_173);
  not(i_173, S1);
  not(i_174, S0);
  and(i_175, i_176, S0);
  and(i_176, B, i_177);
  not(i_177, S1);
  and(i_178, i_179, S0);
  and(i_179, D, S1);
  and(i_180, i_181, i_182);
  and(i_181, C, S1);
  not(i_182, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X2 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_99);
  or(i_99, i_100, i_111);
  or(i_100, i_101, i_109);
  or(i_101, i_102, i_106);
  and(i_102, i_103, i_105);
  and(i_103, A, i_104);
  not(i_104, S1);
  not(i_105, S0);
  and(i_106, i_107, S0);
  and(i_107, B, i_108);
  not(i_108, S1);
  and(i_109, i_110, S0);
  and(i_110, D, S1);
  and(i_111, i_112, i_113);
  and(i_112, C, S1);
  not(i_113, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X3 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_102);
  or(i_102, i_103, i_114);
  or(i_103, i_104, i_112);
  or(i_104, i_105, i_109);
  and(i_105, i_106, i_108);
  and(i_106, A, i_107);
  not(i_107, S1);
  not(i_108, S0);
  and(i_109, i_110, S0);
  and(i_110, B, i_111);
  not(i_111, S1);
  and(i_112, i_113, S0);
  and(i_113, D, S1);
  and(i_114, i_115, i_116);
  and(i_115, C, S1);
  not(i_116, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X4 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_60);
  or(i_60, i_61, i_72);
  or(i_61, i_62, i_70);
  or(i_62, i_63, i_67);
  and(i_63, i_64, i_66);
  and(i_64, A, i_65);
  not(i_65, S1);
  not(i_66, S0);
  and(i_67, i_68, S0);
  and(i_68, B, i_69);
  not(i_69, S1);
  and(i_70, i_71, S0);
  and(i_71, D, S1);
  and(i_72, i_73, i_74);
  and(i_73, C, S1);
  not(i_74, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X6 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_99);
  or(i_99, i_100, i_111);
  or(i_100, i_101, i_109);
  or(i_101, i_102, i_106);
  and(i_102, i_103, i_105);
  and(i_103, A, i_104);
  not(i_104, S1);
  not(i_105, S0);
  and(i_106, i_107, S0);
  and(i_107, B, i_108);
  not(i_108, S1);
  and(i_109, i_110, S0);
  and(i_110, D, S1);
  and(i_111, i_112, i_113);
  and(i_112, C, S1);
  not(i_113, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module IMUX4X8 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  not(Q, i_75);
  or(i_75, i_76, i_87);
  or(i_76, i_77, i_85);
  or(i_77, i_78, i_82);
  and(i_78, i_79, i_81);
  and(i_79, A, i_80);
  not(i_80, S1);
  not(i_81, S0);
  and(i_82, i_83, S0);
  and(i_83, B, i_84);
  not(i_84, S1);
  and(i_85, i_86, S0);
  and(i_86, D, S1);
  and(i_87, i_88, i_89);
  and(i_88, C, S1);
  not(i_89, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX1 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX2 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX3 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX4 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX6 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX8 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX12 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX16 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX24 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

module INVX32 (A, Q);
  input A;
  output Q;

  not(Q, A);

  specify
    (A => Q) = (0.0, 0.0);
  endspecify

endmodule

primitive \seq_LGNX1  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           1           0           ?       : ? :           0;
           1           1           ?       : ? :           1;
           0           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGNX1 (CLK, E, GCK);
  input CLK;
  input E;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGNX1 (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK_d, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK_d);
    not(i_14, ENL);
    buf(nextstate, E_d);

  `else
    \seq_LGNX1 (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK);
    not(i_14, ENL);
    buf(nextstate, E);

  `endif

  specify
    if((E == 1'b0)) (posedge CLK => (GCK +: 1'b1)) = (0.0, 0.0);
    if((E == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGPX1  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           0           0           ?       : ? :           0;
           0           1           ?       : ? :           1;
           1           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGPX1 (CLK, E, GCK);
  input CLK;
  input E;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGPX1 (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK_d, ENL);
    buf(nextstate, E_d);

  `else
    \seq_LGPX1 (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK, ENL);
    buf(nextstate, E);

  `endif

  specify
    if((E == 1'b0)) (negedge CLK => (GCK +: 1'b0)) = (0.0, 0.0);
    if((E == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGSNX1  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           1           0           ?       : ? :           0;
           1           1           ?       : ? :           1;
           0           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGSNX1 (CLK, E, SE, GCK);
  input CLK;
  input E;
  input SE;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGSNX1 (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK_d, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK_d);
    not(i_14, ENL);
    or(nextstate, E_d, SE_d);

  `else
    \seq_LGSNX1 (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    or(GCK, CLK, i_12);
    and(i_12, i_13, i_14);
    not(i_13, CLK);
    not(i_14, ENL);
    or(nextstate, E, SE);

  `endif

  specify
    if((E == 1'b0) && (SE == 1'b0)) (posedge CLK => (GCK +: 1'b1)) = (0.0, 0.0);
    if((E == 1'b0) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b0)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, negedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(negedge CLK, posedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge CLK, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LGSPX1  (ENL, CLK, nextstate, NOTIFIER);
  output ENL;
  input CLK;
  input nextstate;
  input NOTIFIER;
  reg ENL;

  table
      // CLK   nextstate    NOTIFIER    : @ENL :         ENL
           0           0           ?       : ? :           0;
           0           1           ?       : ? :           1;
           1           ?           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           *           ?       : ? :           -; // Ignore all edges on nextstate
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LGSPX1 (CLK, E, SE, GCK);
  input CLK;
  input E;
  input SE;
  output GCK;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LGSPX1 (ENL, CLK_d, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK_d, ENL);
    or(nextstate, E_d, SE_d);

  `else
    \seq_LGSPX1 (ENL, CLK, nextstate, NOTIFIER);
    not(ENLn, ENL);
    and(GCK, CLK, ENL);
    or(nextstate, E, SE);

  `endif

  specify
    if((E == 1'b0) && (SE == 1'b0)) (negedge CLK => (GCK +: 1'b0)) = (0.0, 0.0);
    if((E == 1'b0) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b0)) (CLK => GCK) = (0.0, 0.0);
    if((E == 1'b1) && (SE == 1'b1)) (CLK => GCK) = (0.0, 0.0);
    `ifdef NTC
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, negedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER, , ,CLK_d, E_d);
      $setuphold(posedge CLK, posedge SE, 0.0, 0.0, NOTIFIER, , ,CLK_d, SE_d);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge CLK, negedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, negedge SE, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge E, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge CLK, posedge SE, 0.0, 0.0, NOTIFIER);
      $width(negedge CLK, 0.0, 0, NOTIFIER);
      $width(posedge CLK, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX1  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX1 (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX1 (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCPX1 (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX2  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX2 (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX2 (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LHCPX2 (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX3  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX3 (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX3 (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_11, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHCPX3 (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_10, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX4  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX4 (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX4 (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_17, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LHCPX4 (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_16, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCPX6  (IQ, SN, RN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           ?           0           1           ?       : ? :           0;
           ?           1           1           1           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCPX6 (D, E, RN, SN, Q, QN);
  input D;
  input E;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LHCPX6 (IQ, SN_d, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_11, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHCPX6 (IQ, SN, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_10, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule


primitive \seq_LHCX1  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX1 (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX1 (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LHCX1 (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX2  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX2 (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX2 (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_LHCX2 (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule


primitive \seq_LHCX3  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX3 (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX3 (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_23, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_23, id_23, 1'b1);
    `endif
  `else
    \seq_LHCX3 (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_22, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_22, id_22, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_23), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_23), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_23), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_22), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_22), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_22), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX4  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX4 (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX4 (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHCX4 (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHCX6  (IQ, RN, nextstate, E, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate           E    NOTIFIER     : @IQ :          IQ
           ?           0           1           ?       : ? :           0;
           1           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHCX6 (D, E, RN, Q, QN);
  input D;
  input E;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LHCX6 (IQ, RN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LHCX6 (IQ, RN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => Q) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b1)) (RN => QN) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, negedge E, 0.0, 0.0, NOTIFIER, , ,RN_di, E_d);
      `else
        $hold(negedge E, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX1  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX1 (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX1 (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHPX1 (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX2  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX2 (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX2 (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_17, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_17, id_17, 1'b1);
    `endif
  `else
    \seq_LHPX2 (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_16, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_16, id_16, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_17), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_17), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_17), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_16), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_16), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX3  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX3 (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX3 (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHPX3 (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX4  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX4 (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX4 (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LHPX4 (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_5), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_4), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHPX6  (IQ, SN, nextstate, E, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate           E    NOTIFIER     : @IQ :          IQ
           1           0           1           ?       : ? :           0;
           ?           1           1           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHPX6 (D, E, SN, Q, QN);
  input D;
  input E;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LHPX6 (IQ, SN_d, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LHPX6 (IQ, SN, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (E == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (E == 1'b0)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, negedge E, 0.0, 0.0, NOTIFIER, , ,SN_di, E_d);
      `else
        $hold(negedge E, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      `endif
      $setuphold(negedge E &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_11), 0.0, 0, NOTIFIER);
    `else
      $hold(negedge E, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, negedge E, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
      $width(posedge E &&& (xid_10), 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX1  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX1 (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX1 (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX1 (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX2  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX2 (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX2 (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX2 (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX3  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX3 (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX3 (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX3 (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX4  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX4 (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX4 (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX4 (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LHX6  (IQ, nextstate, E, NOTIFIER);
  output IQ;
  input nextstate;
  input E;
  input NOTIFIER;
  reg IQ;

  table
// nextstate           E    NOTIFIER     : @IQ :          IQ
           0           1           ?       : ? :           0;
           1           1           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           0           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LHX6 (D, E, Q, QN);
  input D;
  input E;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LHX6 (IQ, nextstate, E_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LHX6 (IQ, nextstate, E, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (posedge E => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (posedge E => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER, , ,E_d, D_d);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `else
      $setuphold(negedge E, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(negedge E, posedge D, 0.0, 0.0, NOTIFIER);
      $width(posedge E, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX1  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX1 (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX1 (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX1 (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX2  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX2 (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX2 (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX2 (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX3  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX3 (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX3 (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX3 (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX4  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX4 (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX4 (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX4 (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCPX6  (IQ, SN, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN          RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           ?           0           0           ?       : ? :           0;
           ?           1           1           0           ?       : ? :           1;
           1           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?           ?       : ? :           1; // SN activated
           *           1           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           1           0           ?           ?           ?       : ? :           0; // RN activated
           1           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCPX6 (D, EN, RN, SN, Q, QN);
  input D;
  input EN;
  input RN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
      buf (RN_d, RN_di);
    `else
      buf (SN_d, SN);
      buf (RN_d, RN);
    `endif
    \seq_LNCPX6 (IQ, SN_d, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    and(id_5, SN_d, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCPX6 (IQ, SN, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    and(id_4, SN, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (SN == 1'b1)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (SN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b0) && (RN == 1'b1)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1) && (RN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX1  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX1 (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX1 (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX1 (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX2  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX2 (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX2 (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX2 (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX3  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX3 (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX3 (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNCX3 (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX4  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX4 (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX4 (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNCX4 (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNCX6  (IQ, RN, nextstate, EN, NOTIFIER);
  output IQ;
  input RN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // RN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           ?           0           0           ?       : ? :           0;
           1           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           0; // RN activated
           *           ?           ?           ?       : 0 :           0; // Cover all transitions on RN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNCX6 (D, EN, RN, Q, QN);
  input D;
  input EN;
  input RN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (RN_d, RN_di);
    `else
      buf (RN_d, RN);
    `endif
    \seq_LNCX6 (IQ, RN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, RN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNCX6 (IQ, RN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, RN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => Q) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (Q +: 1'b0)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b0)) (RN => QN) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge RN => (QN +: 1'b1)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge RN, posedge EN, 0.0, 0.0, NOTIFIER, , ,RN_di, EN_d);
      `else
        $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
        $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge RN, 0.0, NOTIFIER);
      $recovery(posedge RN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge RN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX1  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX1 (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX1 (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNPX1 (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX2  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX2 (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX2 (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNPX2 (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX3  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX3 (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX3 (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_11, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_11, id_11, 1'b1);
    `endif
  `else
    \seq_LNPX3 (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_10, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_10, id_10, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_11), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_11), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_11), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_10), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_10), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX4  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX4 (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX4 (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNPX4 (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNPX6  (IQ, SN, nextstate, EN, NOTIFIER);
  output IQ;
  input SN;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
       // SN   nextstate          EN    NOTIFIER     : @IQ :          IQ
           1           0           0           ?       : ? :           0;
           ?           1           0           ?       : ? :           1;
           1           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           1           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           0           ?           ?           ?       : ? :           1; // SN activated
           *           ?           ?           ?       : 1 :           1; // Cover all transitions on SN
           ?           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNPX6 (D, EN, SN, Q, QN);
  input D;
  input EN;
  input SN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    `ifdef RECREM
      buf (SN_d, SN_di);
    `else
      buf (SN_d, SN);
    `endif
    \seq_LNPX6 (IQ, SN_d, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

    // Delayed data/reference logic
    buf(id_5, SN_d);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_5, id_5, 1'b1);
    `endif
  `else
    \seq_LNPX6 (IQ, SN, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

    // Delayed data/reference logic
    buf(id_4, SN);

    `ifdef TETRAMAX
    `else
      ng_xbuf(xid_4, id_4, 1'b1);
    `endif
  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => Q) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (Q +: 1'b1)) = (0.0, 0.0);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    if((D == 1'b0) && (EN == 1'b0)) (SN => QN) = (0.0, 0.0);
    if((D == 1'b0) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    if((D == 1'b1) && (EN == 1'b1)) (negedge SN => (QN +: 1'b0)) = (0.0, 0.0);
    `ifdef NTC
      `ifdef RECREM
        $recrem(posedge SN, posedge EN, 0.0, 0.0, NOTIFIER, , ,SN_di, EN_d);
      `else
        $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
        $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      `endif
      $setuphold(posedge EN &&& (xid_5), negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN &&& (xid_5), posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN &&& (xid_5), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `else
      $hold(posedge EN, posedge SN, 0.0, NOTIFIER);
      $recovery(posedge SN, posedge EN, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN &&& (xid_4), posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN &&& (xid_4), 0.0, 0, NOTIFIER);
      $width(negedge SN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX1  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX1 (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX1 (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX1 (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX2  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX2 (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX2 (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX2 (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX3  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX3 (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX3 (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX3 (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX4  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX4 (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX4 (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX4 (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

primitive \seq_LNX6  (IQ, nextstate, EN, NOTIFIER);
  output IQ;
  input nextstate;
  input EN;
  input NOTIFIER;
  reg IQ;

  table
// nextstate          EN    NOTIFIER     : @IQ :          IQ
           0           0           ?       : ? :           0;
           1           0           ?       : ? :           1;
           *           ?           ?       : ? :           -; // Ignore all edges on nextstate
           ?           1           ?       : ? :           -; // Ignore non-triggering clock edge
           ?           ?           *       : ? :           x; // Any NOTIFIER change
  endtable
endprimitive

module LNX6 (D, EN, Q, QN);
  input D;
  input EN;
  output Q;
  output QN;
  reg NOTIFIER;

  `ifdef NTC
    \seq_LNX6 (IQ, nextstate, EN_d, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D_d);

  `else
    \seq_LNX6 (IQ, nextstate, EN, NOTIFIER);
    not(IQN, IQ);
    buf(Q, IQ);
    buf(QN, IQN);
    buf(nextstate, D);

  `endif

  specify
    (D => Q) = (0.0, 0.0);
    (negedge EN => (Q +: D)) = (0.1, 0.1);
    (D => QN) = (0.0, 0.0);
    (negedge EN => (QN -: D)) = (0.1, 0.1);
    `ifdef NTC
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER, , ,EN_d, D_d);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `else
      $setuphold(posedge EN, negedge D, 0.0, 0.0, NOTIFIER);
      $setuphold(posedge EN, posedge D, 0.0, 0.0, NOTIFIER);
      $width(negedge EN, 0.0, 0, NOTIFIER);
    `endif
  endspecify

endmodule

module MAJ3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_307, i_310);
  or(i_307, i_308, i_309);
  and(i_308, B, A);
  and(i_309, C, B);
  and(i_310, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_220, i_223);
  or(i_220, i_221, i_222);
  and(i_221, B, A);
  and(i_222, C, B);
  and(i_223, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_343, i_346);
  or(i_343, i_344, i_345);
  and(i_344, B, A);
  and(i_345, C, B);
  and(i_346, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MAJ3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_340, i_343);
  or(i_340, i_341, i_342);
  and(i_341, B, A);
  and(i_342, C, B);
  and(i_343, C, A);

  specify
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X1 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_258, i_260);
  and(i_258, A, i_259);
  not(i_259, S);
  and(i_260, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X2 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_216, i_218);
  and(i_216, A, i_217);
  not(i_217, S);
  and(i_218, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X3 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_468, i_470);
  and(i_468, A, i_469);
  not(i_469, S);
  and(i_470, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X4 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_381, i_383);
  and(i_381, A, i_382);
  not(i_382, S);
  and(i_383, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X6 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_423, i_425);
  and(i_423, A, i_424);
  not(i_424, S);
  and(i_425, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX2X8 (A, B, S, Q);
  input A;
  input B;
  input S;
  output Q;

  or(Q, i_354, i_356);
  and(i_354, A, i_355);
  not(i_355, S);
  and(i_356, B, S);

  specify
    if((B == 1'b0) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (S == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (S == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (S => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (S => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X1 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_60, i_68);
  or(i_60, i_61, i_65);
  and(i_61, i_62, i_64);
  and(i_62, A, i_63);
  not(i_63, S1);
  not(i_64, S0);
  and(i_65, i_66, S0);
  and(i_66, B, i_67);
  not(i_67, S1);
  and(i_68, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X2 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_192, i_200);
  or(i_192, i_193, i_197);
  and(i_193, i_194, i_196);
  and(i_194, A, i_195);
  not(i_195, S1);
  not(i_196, S0);
  and(i_197, i_198, S0);
  and(i_198, B, i_199);
  not(i_199, S1);
  and(i_200, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X3 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_96, i_104);
  or(i_96, i_97, i_101);
  and(i_97, i_98, i_100);
  and(i_98, A, i_99);
  not(i_99, S1);
  not(i_100, S0);
  and(i_101, i_102, S0);
  and(i_102, B, i_103);
  not(i_103, S1);
  and(i_104, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X4 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_159, i_167);
  or(i_159, i_160, i_164);
  and(i_160, i_161, i_163);
  and(i_161, A, i_162);
  not(i_162, S1);
  not(i_163, S0);
  and(i_164, i_165, S0);
  and(i_165, B, i_166);
  not(i_166, S1);
  and(i_167, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X6 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_189, i_197);
  or(i_189, i_190, i_194);
  and(i_190, i_191, i_193);
  and(i_191, A, i_192);
  not(i_192, S1);
  not(i_193, S0);
  and(i_194, i_195, S0);
  and(i_195, B, i_196);
  not(i_196, S1);
  and(i_197, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX3X8 (A, B, C, S0, S1, Q);
  input A;
  input B;
  input C;
  input S0;
  input S1;
  output Q;

  or(Q, i_69, i_77);
  or(i_69, i_70, i_74);
  and(i_70, i_71, i_73);
  and(i_71, A, i_72);
  not(i_72, S1);
  not(i_73, S0);
  and(i_74, i_75, S0);
  and(i_75, B, i_76);
  not(i_76, S1);
  and(i_77, C, S1);

  specify
    if((B == 1'b0) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X1 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X2 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_176, i_187);
  or(i_176, i_177, i_185);
  or(i_177, i_178, i_182);
  and(i_178, i_179, i_181);
  and(i_179, A, i_180);
  not(i_180, S1);
  not(i_181, S0);
  and(i_182, i_183, S0);
  and(i_183, B, i_184);
  not(i_184, S1);
  and(i_185, i_186, S0);
  and(i_186, D, S1);
  and(i_187, i_188, i_189);
  and(i_188, C, S1);
  not(i_189, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X3 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_80, i_91);
  or(i_80, i_81, i_89);
  or(i_81, i_82, i_86);
  and(i_82, i_83, i_85);
  and(i_83, A, i_84);
  not(i_84, S1);
  not(i_85, S0);
  and(i_86, i_87, S0);
  and(i_87, B, i_88);
  not(i_88, S1);
  and(i_89, i_90, S0);
  and(i_90, D, S1);
  and(i_91, i_92, i_93);
  and(i_92, C, S1);
  not(i_93, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X4 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_71, i_82);
  or(i_71, i_72, i_80);
  or(i_72, i_73, i_77);
  and(i_73, i_74, i_76);
  and(i_74, A, i_75);
  not(i_75, S1);
  not(i_76, S0);
  and(i_77, i_78, S0);
  and(i_78, B, i_79);
  not(i_79, S1);
  and(i_80, i_81, S0);
  and(i_81, D, S1);
  and(i_82, i_83, i_84);
  and(i_83, C, S1);
  not(i_84, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module MUX4X6 (A, B, C, D, S0, S1, Q);
  input A;
  input B;
  input C;
  input D;
  input S0;
  input S1;
  output Q;

  or(Q, i_56, i_67);
  or(i_56, i_57, i_65);
  or(i_57, i_58, i_62);
  and(i_58, i_59, i_61);
  and(i_59, A, i_60);
  not(i_60, S1);
  not(i_61, S0);
  and(i_62, i_63, S0);
  and(i_63, B, i_64);
  not(i_64, S1);
  and(i_65, i_66, S0);
  and(i_66, D, S1);
  and(i_67, i_68, i_69);
  and(i_68, C, S1);
  not(i_69, S0);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b0)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1) && (S1 == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1) && (S0 == 1'b0) && (S1 == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (S0 == 1'b1) && (S1 == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S1 == 1'b0)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S1 == 1'b1)) (S0 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1) && (D == 1'b1) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0) && (D == 1'b1) && (S0 == 1'b0)) (S1 => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1) && (D == 1'b0) && (S0 == 1'b1)) (S1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X1 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_322);
  and(i_322, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X2 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_592);
  and(i_592, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X3 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_505);
  and(i_505, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X4 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_460);
  and(i_460, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X6 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_478);
  and(i_478, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X8 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_280);
  and(i_280, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND2X12 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_424);
  and(i_424, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_272);
  and(i_272, i_273, C);
  and(i_273, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_278);
  and(i_278, i_279, C);
  and(i_279, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_302);
  and(i_302, i_303, C);
  and(i_303, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_374);
  and(i_374, i_375, C);
  and(i_375, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X6 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_302);
  and(i_302, i_303, C);
  and(i_303, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X8 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_374);
  and(i_374, i_375, C);
  and(i_375, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND3X12 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_227);
  and(i_227, i_228, C);
  and(i_228, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X1 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_222);
  and(i_222, i_223, D);
  and(i_223, i_224, C);
  and(i_224, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X2 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_156);
  and(i_156, i_157, D);
  and(i_157, i_158, C);
  and(i_158, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X3 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_186);
  and(i_186, i_187, D);
  and(i_187, i_188, C);
  and(i_188, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X4 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_258);
  and(i_258, i_259, D);
  and(i_259, i_260, C);
  and(i_260, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X6 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_150);
  and(i_150, i_151, D);
  and(i_151, i_152, C);
  and(i_152, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NAND4X8 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_192);
  and(i_192, i_193, D);
  and(i_193, i_194, C);
  and(i_194, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X1 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_370);
  or(i_370, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X2 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_331);
  or(i_331, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X3 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_244);
  or(i_244, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X4 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_448);
  or(i_448, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X6 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_274);
  or(i_274, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X8 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_238);
  or(i_238, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR2X12 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_469);
  or(i_469, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_206);
  or(i_206, i_207, C);
  or(i_207, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_287);
  or(i_287, i_288, C);
  or(i_288, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_407);
  or(i_407, i_408, C);
  or(i_408, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_404);
  or(i_404, i_405, C);
  or(i_405, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X6 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_242);
  or(i_242, i_243, C);
  or(i_243, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X8 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_323);
  or(i_323, i_324, C);
  or(i_324, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR3X12 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_200);
  or(i_200, i_201, C);
  or(i_201, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X1 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_150);
  or(i_150, i_151, D);
  or(i_151, i_152, C);
  or(i_152, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X2 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_354);
  or(i_354, i_355, D);
  or(i_355, i_356, C);
  or(i_356, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X3 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_240);
  or(i_240, i_241, D);
  or(i_241, i_242, C);
  or(i_242, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X4 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_273);
  or(i_273, i_274, D);
  or(i_274, i_275, C);
  or(i_275, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X6 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_168);
  or(i_168, i_169, D);
  or(i_169, i_170, C);
  or(i_170, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module NOR4X8 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_324);
  or(i_324, i_325, D);
  or(i_325, i_326, C);
  or(i_326, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
    (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X1 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_200);
  and(i_200, i_201, B1);
  or(i_201, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X2 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_320);
  and(i_320, i_321, B1);
  or(i_321, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X3 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_365);
  and(i_365, i_366, B1);
  or(i_366, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X4 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_452);
  and(i_452, i_453, B1);
  or(i_453, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X6 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_407);
  and(i_407, i_408, B1);
  or(i_408, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI21X8 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  not(Q, i_338);
  and(i_338, i_339, B1);
  or(i_339, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X1 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_177);
  and(i_177, i_178, i_179);
  or(i_178, A1, A2);
  or(i_179, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X2 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_156);
  and(i_156, i_157, i_158);
  or(i_157, A1, A2);
  or(i_158, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X3 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_273);
  and(i_273, i_274, i_275);
  or(i_274, A1, A2);
  or(i_275, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X4 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_138);
  and(i_138, i_139, i_140);
  or(i_139, A1, A2);
  or(i_140, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X6 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_138);
  and(i_138, i_139, i_140);
  or(i_139, A1, A2);
  or(i_140, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI22X8 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  not(Q, i_273);
  and(i_273, i_274, i_275);
  or(i_274, A1, A2);
  or(i_275, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X1 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_270);
  and(i_270, i_271, B1);
  or(i_271, i_272, A3);
  or(i_272, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X2 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_153);
  and(i_153, i_154, B1);
  or(i_154, i_155, A3);
  or(i_155, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X3 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_204);
  and(i_204, i_205, B1);
  or(i_205, i_206, A3);
  or(i_206, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X4 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_231);
  and(i_231, i_232, B1);
  or(i_232, i_233, A3);
  or(i_233, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X6 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_168);
  and(i_168, i_169, B1);
  or(i_169, i_170, A3);
  or(i_170, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI31X8 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  not(Q, i_240);
  and(i_240, i_241, B1);
  or(i_241, i_242, A3);
  or(i_242, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X1 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_130);
  and(i_130, i_131, i_133);
  or(i_131, i_132, A3);
  or(i_132, A1, A2);
  or(i_133, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X2 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_58);
  and(i_58, i_59, i_61);
  or(i_59, i_60, A3);
  or(i_60, A1, A2);
  or(i_61, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X3 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_91);
  and(i_91, i_92, i_94);
  or(i_92, i_93, A3);
  or(i_93, A1, A2);
  or(i_94, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X4 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_238);
  and(i_238, i_239, i_241);
  or(i_239, i_240, A3);
  or(i_240, A1, A2);
  or(i_241, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X6 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_52);
  and(i_52, i_53, i_55);
  or(i_53, i_54, A3);
  or(i_54, A1, A2);
  or(i_55, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI32X8 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  not(Q, i_52);
  and(i_52, i_53, i_55);
  or(i_53, i_54, A3);
  or(i_54, A1, A2);
  or(i_55, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X1 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_132);
  and(i_132, i_133, C1);
  and(i_133, i_134, B1);
  or(i_134, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X2 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_174);
  and(i_174, i_175, C1);
  and(i_175, i_176, B1);
  or(i_176, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X3 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_132);
  and(i_132, i_133, C1);
  and(i_133, i_134, B1);
  or(i_134, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X4 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_336);
  and(i_336, i_337, C1);
  and(i_337, i_338, B1);
  or(i_338, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X6 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_222);
  and(i_222, i_223, C1);
  and(i_223, i_224, B1);
  or(i_224, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI211X8 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  not(Q, i_255);
  and(i_255, i_256, C1);
  and(i_256, i_257, B1);
  or(i_257, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X1 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_142);
  and(i_142, i_143, C1);
  and(i_143, i_144, i_145);
  or(i_144, A1, A2);
  or(i_145, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X2 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_118);
  and(i_118, i_119, C1);
  and(i_119, i_120, i_121);
  or(i_120, A1, A2);
  or(i_121, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X3 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_52);
  and(i_52, i_53, C1);
  and(i_53, i_54, i_55);
  or(i_54, A1, A2);
  or(i_55, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X4 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_133);
  and(i_133, i_134, C1);
  and(i_134, i_135, i_136);
  or(i_135, A1, A2);
  or(i_136, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X6 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_40);
  and(i_40, i_41, C1);
  and(i_41, i_42, i_43);
  or(i_42, A1, A2);
  or(i_43, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI221X8 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  not(Q, i_214);
  and(i_214, i_215, C1);
  and(i_215, i_216, i_217);
  or(i_216, A1, A2);
  or(i_217, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X1 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_16);
  and(i_16, i_17, C1);
  and(i_17, i_18, B1);
  or(i_18, i_19, A3);
  or(i_19, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X2 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_145);
  and(i_145, i_146, C1);
  and(i_146, i_147, B1);
  or(i_147, i_148, A3);
  or(i_148, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X3 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_148);
  and(i_148, i_149, C1);
  and(i_149, i_150, B1);
  or(i_150, i_151, A3);
  or(i_151, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X4 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_52);
  and(i_52, i_53, C1);
  and(i_53, i_54, B1);
  or(i_54, i_55, A3);
  or(i_55, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X6 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_145);
  and(i_145, i_146, C1);
  and(i_146, i_147, B1);
  or(i_147, i_148, A3);
  or(i_148, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OAI311X8 (A1, A2, A3, B1, C1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input C1;
  output Q;

  not(Q, i_106);
  and(i_106, i_107, C1);
  and(i_107, i_108, B1);
  or(i_108, i_109, A3);
  or(i_109, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X1 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_262, B1);
  or(i_262, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X2 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_268, B1);
  or(i_268, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X3 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_292, B1);
  or(i_292, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X4 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_364, B1);
  or(i_364, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X6 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_217, B1);
  or(i_217, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA21X8 (A1, A2, B1, Q);
  input A1;
  input A2;
  input B1;
  output Q;

  and(Q, i_196, B1);
  or(i_196, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X1 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_152, i_153);
  or(i_152, A1, A2);
  or(i_153, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X2 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_308, i_309);
  or(i_308, A1, A2);
  or(i_309, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X3 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_161, i_162);
  or(i_161, A1, A2);
  or(i_162, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X4 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_257, i_258);
  or(i_257, A1, A2);
  or(i_258, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X6 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_122, i_123);
  or(i_122, A1, A2);
  or(i_123, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA22X8 (A1, A2, B1, B2, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  output Q;

  and(Q, i_254, i_255);
  or(i_254, A1, A2);
  or(i_255, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X1 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_140, B1);
  or(i_140, i_141, A3);
  or(i_141, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X2 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_122, B1);
  or(i_122, i_123, A3);
  or(i_123, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X3 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_257, B1);
  or(i_257, i_258, A3);
  or(i_258, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X4 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_137, B1);
  or(i_137, i_138, A3);
  or(i_138, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X6 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_188, B1);
  or(i_188, i_189, A3);
  or(i_189, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA31X8 (A1, A2, A3, B1, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  output Q;

  and(Q, i_215, B1);
  or(i_215, i_216, A3);
  or(i_216, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1)) (B1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X1 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_117, i_119);
  or(i_117, i_118, A3);
  or(i_118, A1, A2);
  or(i_119, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X2 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_27, i_29);
  or(i_27, i_28, A3);
  or(i_28, A1, A2);
  or(i_29, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X3 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_36, i_38);
  or(i_36, i_37, A3);
  or(i_37, A1, A2);
  or(i_38, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X4 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_69, i_71);
  or(i_69, i_70, A3);
  or(i_70, A1, A2);
  or(i_71, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X6 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_30, i_32);
  or(i_30, i_31, A3);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA32X8 (A1, A2, A3, B1, B2, Q);
  input A1;
  input A2;
  input A3;
  input B1;
  input B2;
  output Q;

  and(Q, i_216, i_218);
  or(i_216, i_217, A3);
  or(i_217, A1, A2);
  or(i_218, B1, B2);

  specify
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (A3 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B2 == 1'b0)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b0) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (A3 == 1'b1) && (B1 == 1'b0)) (B2 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X1 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_152, C1);
  and(i_152, i_153, B1);
  or(i_153, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X2 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_116, C1);
  and(i_116, i_117, B1);
  or(i_117, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X3 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_296, C1);
  and(i_296, i_297, B1);
  or(i_297, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X4 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_149, C1);
  and(i_149, i_150, B1);
  or(i_150, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X6 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_110, C1);
  and(i_110, i_111, B1);
  or(i_111, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA211X8 (A1, A2, B1, C1, Q);
  input A1;
  input A2;
  input B1;
  input C1;
  output Q;

  and(Q, i_128, C1);
  and(i_128, i_129, B1);
  or(i_129, A1, A2);

  specify
    (A1 => Q) = (0.0, 0.0);
    (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X1 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_30, C1);
  and(i_30, i_31, i_32);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X2 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_120, C1);
  and(i_120, i_121, i_122);
  or(i_121, A1, A2);
  or(i_122, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X3 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_96, C1);
  and(i_96, i_97, i_98);
  or(i_97, A1, A2);
  or(i_98, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X4 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_30, C1);
  and(i_30, i_31, i_32);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X6 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_111, C1);
  and(i_111, i_112, i_113);
  or(i_112, A1, A2);
  or(i_113, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OA221X8 (A1, A2, B1, B2, C1, Q);
  input A1;
  input A2;
  input B1;
  input B2;
  input C1;
  output Q;

  and(Q, i_30, C1);
  and(i_30, i_31, i_32);
  or(i_31, A1, A2);
  or(i_32, B1, B2);

  specify
    if((A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1) && (C1 == 1'b1)) (A2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B2 == 1'b0) && (C1 == 1'b1)) (B1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (C1 == 1'b1)) (B2 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b0) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b0) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b0) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b0)) (C1 => Q) = (0.0, 0.0);
    if((A1 == 1'b1) && (A2 == 1'b1) && (B1 == 1'b1) && (B2 == 1'b1)) (C1 => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X1 (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X2 (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X3 (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X4 (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X6 (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR2X8 (A, B, Q);
  input A;
  input B;
  output Q;

  or(Q, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_394, C);
  or(i_394, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_232, C);
  or(i_232, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_190, C);
  or(i_190, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_313, C);
  or(i_313, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X6 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_310, C);
  or(i_310, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module OR3X8 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  or(Q, i_190, C);
  or(i_190, A, B);

  specify
    (A => Q) = (0.0, 0.0);
    (B => Q) = (0.0, 0.0);
    (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X1 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_541);
  xor(i_541, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X2 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_463);
  xor(i_463, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X3 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_586);
  xor(i_586, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X4 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_499);
  xor(i_499, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X6 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_472);
  xor(i_472, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR2X8 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_418);
  xor(i_418, B, A);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_336);
  not(i_336, i_337);
  or(i_337, i_338, i_344);
  and(i_338, i_339, C);
  not(i_339, i_340);
  or(i_340, i_341, i_342);
  and(i_341, A, B);
  not(i_342, i_343);
  or(i_343, A, B);
  not(i_344, i_345);
  or(i_345, i_346, C);
  not(i_346, i_347);
  or(i_347, i_348, i_349);
  and(i_348, A, B);
  not(i_349, i_350);
  or(i_350, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_264);
  not(i_264, i_265);
  or(i_265, i_266, i_272);
  and(i_266, i_267, C);
  not(i_267, i_268);
  or(i_268, i_269, i_270);
  and(i_269, A, B);
  not(i_270, i_271);
  or(i_271, A, B);
  not(i_272, i_273);
  or(i_273, i_274, C);
  not(i_274, i_275);
  or(i_275, i_276, i_277);
  and(i_276, A, B);
  not(i_277, i_278);
  or(i_278, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_369);
  not(i_369, i_370);
  or(i_370, i_371, i_377);
  and(i_371, i_372, C);
  not(i_372, i_373);
  or(i_373, i_374, i_375);
  and(i_374, A, B);
  not(i_375, i_376);
  or(i_376, A, B);
  not(i_377, i_378);
  or(i_378, i_379, C);
  not(i_379, i_380);
  or(i_380, i_381, i_382);
  and(i_381, A, B);
  not(i_382, i_383);
  or(i_383, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_249);
  not(i_249, i_250);
  or(i_250, i_251, i_257);
  and(i_251, i_252, C);
  not(i_252, i_253);
  or(i_253, i_254, i_255);
  and(i_254, A, B);
  not(i_255, i_256);
  or(i_256, A, B);
  not(i_257, i_258);
  or(i_258, i_259, C);
  not(i_259, i_260);
  or(i_260, i_261, i_262);
  and(i_261, A, B);
  not(i_262, i_263);
  or(i_263, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X6 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_327);
  not(i_327, i_328);
  or(i_328, i_329, i_335);
  and(i_329, i_330, C);
  not(i_330, i_331);
  or(i_331, i_332, i_333);
  and(i_332, A, B);
  not(i_333, i_334);
  or(i_334, A, B);
  not(i_335, i_336);
  or(i_336, i_337, C);
  not(i_337, i_338);
  or(i_338, i_339, i_340);
  and(i_339, A, B);
  not(i_340, i_341);
  or(i_341, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR3X8 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_369);
  not(i_369, i_370);
  or(i_370, i_371, i_377);
  and(i_371, i_372, C);
  not(i_372, i_373);
  or(i_373, i_374, i_375);
  and(i_374, A, B);
  not(i_375, i_376);
  or(i_376, A, B);
  not(i_377, i_378);
  or(i_378, i_379, C);
  not(i_379, i_380);
  or(i_380, i_381, i_382);
  and(i_381, A, B);
  not(i_382, i_383);
  or(i_383, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X1 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_114);
  xor(i_114, i_115, A);
  xor(i_115, i_116, B);
  xor(i_116, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X2 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_156);
  xor(i_156, i_157, A);
  xor(i_157, i_158, B);
  xor(i_158, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X3 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_222);
  xor(i_222, i_223, A);
  xor(i_223, i_224, B);
  xor(i_224, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X4 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_204);
  xor(i_204, i_205, A);
  xor(i_205, i_206, B);
  xor(i_206, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X6 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_318);
  xor(i_318, i_319, A);
  xor(i_319, i_320, B);
  xor(i_320, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XNOR4X8 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  not(Q, i_237);
  xor(i_237, i_238, A);
  xor(i_238, i_239, B);
  xor(i_239, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X1 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_358);
  or(i_358, i_359, i_360);
  and(i_359, A, B);
  not(i_360, i_361);
  or(i_361, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X2 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_436);
  or(i_436, i_437, i_438);
  and(i_437, A, B);
  not(i_438, i_439);
  or(i_439, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X3 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_262);
  or(i_262, i_263, i_264);
  and(i_263, A, B);
  not(i_264, i_265);
  or(i_265, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X4 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_457);
  or(i_457, i_458, i_459);
  and(i_458, A, B);
  not(i_459, i_460);
  or(i_460, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X6 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_283);
  or(i_283, i_284, i_285);
  and(i_284, A, B);
  not(i_285, i_286);
  or(i_286, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR2X8 (A, B, Q);
  input A;
  input B;
  output Q;

  not(Q, i_454);
  or(i_454, i_455, i_456);
  and(i_455, A, B);
  not(i_456, i_457);
  or(i_457, A, B);

  specify
    if((B == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1)) (B => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X1 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_416);
  or(i_416, i_417, i_423);
  and(i_417, i_418, C);
  not(i_418, i_419);
  or(i_419, i_420, i_421);
  and(i_420, A, B);
  not(i_421, i_422);
  or(i_422, A, B);
  not(i_423, i_424);
  or(i_424, i_425, C);
  not(i_425, i_426);
  or(i_426, i_427, i_428);
  and(i_427, A, B);
  not(i_428, i_429);
  or(i_429, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X2 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_302);
  or(i_302, i_303, i_309);
  and(i_303, i_304, C);
  not(i_304, i_305);
  or(i_305, i_306, i_307);
  and(i_306, A, B);
  not(i_307, i_308);
  or(i_308, A, B);
  not(i_309, i_310);
  or(i_310, i_311, C);
  not(i_311, i_312);
  or(i_312, i_313, i_314);
  and(i_313, A, B);
  not(i_314, i_315);
  or(i_315, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X3 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_230);
  or(i_230, i_231, i_237);
  and(i_231, i_232, C);
  not(i_232, i_233);
  or(i_233, i_234, i_235);
  and(i_234, A, B);
  not(i_235, i_236);
  or(i_236, A, B);
  not(i_237, i_238);
  or(i_238, i_239, C);
  not(i_239, i_240);
  or(i_240, i_241, i_242);
  and(i_241, A, B);
  not(i_242, i_243);
  or(i_243, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X4 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_236);
  or(i_236, i_237, i_243);
  and(i_237, i_238, C);
  not(i_238, i_239);
  or(i_239, i_240, i_241);
  and(i_240, A, B);
  not(i_241, i_242);
  or(i_242, A, B);
  not(i_243, i_244);
  or(i_244, i_245, C);
  not(i_245, i_246);
  or(i_246, i_247, i_248);
  and(i_247, A, B);
  not(i_248, i_249);
  or(i_249, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X6 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_260);
  or(i_260, i_261, i_267);
  and(i_261, i_262, C);
  not(i_262, i_263);
  or(i_263, i_264, i_265);
  and(i_264, A, B);
  not(i_265, i_266);
  or(i_266, A, B);
  not(i_267, i_268);
  or(i_268, i_269, C);
  not(i_269, i_270);
  or(i_270, i_271, i_272);
  and(i_271, A, B);
  not(i_272, i_273);
  or(i_273, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR3X8 (A, B, C, Q);
  input A;
  input B;
  input C;
  output Q;

  not(Q, i_332);
  or(i_332, i_333, i_339);
  and(i_333, i_334, C);
  not(i_334, i_335);
  or(i_335, i_336, i_337);
  and(i_336, A, B);
  not(i_337, i_338);
  or(i_338, A, B);
  not(i_339, i_340);
  or(i_340, i_341, C);
  not(i_341, i_342);
  or(i_342, i_343, i_344);
  and(i_343, A, B);
  not(i_344, i_345);
  or(i_345, A, B);

  specify
    if((B == 1'b0) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1)) (C => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X1 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_140, A);
  xor(i_140, i_141, B);
  xor(i_141, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X2 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_245, A);
  xor(i_245, i_246, B);
  xor(i_246, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X3 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_242, A);
  xor(i_242, i_243, B);
  xor(i_243, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X4 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_110, A);
  xor(i_110, i_111, B);
  xor(i_111, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X6 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_203, A);
  xor(i_203, i_204, B);
  xor(i_204, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module XOR4X8 (A, B, C, D, Q);
  input A;
  input B;
  input C;
  input D;
  output Q;

  xor(Q, i_140, A);
  xor(i_140, i_141, B);
  xor(i_141, D, C);

  specify
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b0) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b0) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b0)) (A => Q) = (0.0, 0.0);
    if((B == 1'b1) && (C == 1'b1) && (D == 1'b1)) (A => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b0) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b0)) (B => Q) = (0.0, 0.0);
    if((A == 1'b1) && (C == 1'b1) && (D == 1'b1)) (B => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b0)) (C => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (D == 1'b1)) (C => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b0) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b0) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b0)) (D => Q) = (0.0, 0.0);
    if((A == 1'b1) && (B == 1'b1) && (C == 1'b1)) (D => Q) = (0.0, 0.0);
  endspecify

endmodule

module TIE0 (Q);
 output Q;

 buf (Q,0);
 
endmodule


module TIE1 (Q);
 output Q;

 buf (Q,1);
 
endmodule


module TIEDOWN (Q);
 output Q;

 buf (Q,0);
 
endmodule


module TIEUP (Q);
 output Q;

 buf (Q,1);
 
endmodule


module LOGIC0 (Q);
 output Q;

 buf (Q,0);
 
endmodule


module LOGIC1 (Q);
 output Q;

 buf (Q,1);
 
endmodule


module TIEHIGH (Q);
   output Q;
   wire   Q;

// synopsys translate_off
assign Q = 1'b1;
// synopsys translate_on

endmodule


module TIELOW (Q);  
   output Q;
   wire   Q;
   
// synopsys translate_off
assign Q = 1'b0;
// synopsys translate_on

endmodule

module ANTENNA (A);
  input A;
endmodule


module FILLCELLX1 ();

endmodule

module FILLCELLX16 ();

endmodule

module FILLCELLX2 ();

endmodule

module FILLCELLX32 ();

endmodule

module FILLCELLX4 ();

endmodule

module FILLCELLX8 ();

endmodule


module FILLCAPX8 ();

endmodule


module FILLCAPX4 ();

endmodule


module FILLCAPX32 ();

endmodule


module FILLCAPX2 ();

endmodule

module FILLCAPX16 ();

endmodule


module ENDCAPR ();

endmodule


module ENDCAPL ();

endmodule



`ifdef TETRAMAX
`else
  primitive ng_xbuf (o, i, d);
	output o;
	input i, d;
	table
	// i   d   : o
	   0   1   : 0 ;
	   1   1   : 1 ;
	   x   1   : 1 ;
	endtable
  endprimitive
`endif
//
// End of file
//
