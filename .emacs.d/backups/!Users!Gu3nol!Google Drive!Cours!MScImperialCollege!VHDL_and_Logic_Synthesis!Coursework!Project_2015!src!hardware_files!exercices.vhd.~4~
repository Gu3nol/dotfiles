-- Thomas Clarke 2013
-- draw-octant entity modified for variable size vectors
-- used in VHDL & Logic Synthesis Coursework

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY draw_octant IS
  GENERIC(vsize: INTEGER := 12);
  PORT(
    clk, resetx, draw, xbias, disable : IN  std_logic;
    xin, yin                 : IN  std_logic_vector(vsize-1 DOWNTO 0);
    done                     : OUT std_logic;
    x, y                     : OUT std_logic_vector(vsize-1 DOWNTO 0)
    );
END ENTITY draw_octant;

ARCHITECTURE comb OF draw_octant IS

  SIGNAL done1                    : std_logic; -- internal done
  SIGNAL x1, y1                   : unsigned(vsize-1 DOWNTO 0); -- internal x,y
  SIGNAL xincr, yincr, xnew, ynew : unsigned(vsize-1 DOWNTO 0);
  -- note on vector sizes. err1,err2 must be one bit larger to preserve signed error info
  -- error is always adjusted to minimise absolute value of signed error and therefore
  -- can never be larger than vsize bits even though also signed, 12 bits is enough
  SIGNAL error                    : signed(vsize-1 DOWNTO 0);
  SIGNAL err1, err2               : unsigned(vsize DOWNTO 0);

-- OPERATION
--
-- line drawing is initiated by asserting resetx and draw in successive cycles.
-- this loads the initial and final coordinates of the line to be drawn into
-- (x,y) and xnew,ynew0 respectively
-- drawing must be in ENE octant which implies xincr >= 0, yincr >= 0, xincr >= yincr
-- here xincr = x - xnew, yincr = y - ynew
--
-- Through the drawing process (x,y) represent a new point to be plotted on line each cycle.
-- error represents the signed
--
-- xbias determines whether line goes in x direction or xy direction when both directions have
-- equal offset from the true line.
--
-- done is asserted in the final cycle when x=xnew, y=ynew.

--NOTES ON DATA STRUCTURES
-- The basic data here is a (x,y) coordinate
-- it would make sense to use a record type for this:
-- TYPE coord IS RECORD x,y: std-logic_vector(vsize-1 DOWNTO 0) END RECORD;
-- then decalre internal datas tructures of type coord.
-- the result would be neater, and for example testing the end condition could
-- be equality on records which works (like equality on arrays)


BEGIN
  -- assign to ports from internal signals
  x    <= std_logic_vector(x1);
  y    <= std_logic_vector(y1);
  done <= done1;

  C1 : PROCESS(error, xincr, yincr, x1, y1, xnew, ynew, resetx, draw)

  BEGIN

    err1 <= unsigned(abs(resize(error, vsize+1) + signed(resize(yincr,vsize+1))));
    err2 <= unsigned(abs(resize(error, vsize+1) - signed(resize(unsigned(xincr - yincr),vsize+1))));

    done1 <= '0';
    IF x1 = xnew and y1 = ynew and resetx = '0' and draw = '0' THEN
      done1 <= '1';
    END IF;

  END PROCESS C1;

  R1 : PROCESS

  BEGIN
    WAIT UNTIL clk'event AND clk = '1';
    IF disable = '0' THEN
    IF resetx = '1' THEN
      x1    <= unsigned(xin);
      y1    <= unsigned(yin);
      xincr <= (OTHERS => '0');
      yincr <= (OTHERS => '0');
      xnew  <= unsigned(xin);
      ynew  <= unsigned(yin);
      error <= (OTHERS => '0');

    ELSIF draw = '1' THEN
      xincr <= unsigned(xin) - x1;
      yincr <= unsigned(yin) - y1;
      xnew  <= unsigned(xin);
      ynew  <= unsigned(yin);

    ELSIF done1 = '1' THEN
      NULL; -- do nothing more once line has finished until next resetx

	ELSE    -- draw new pixel

      IF err1 > err2 OR (err1 = err2 AND xbias = '0') THEN --check new pixel direction
        -- draw new pixel in diagonal direction
        y1    <= y1 + 1;
        x1    <= x1 + 1;
        error <= error + signed(yincr) - signed(xincr);
      ELSE
        -- draw new pixel in x direction
        x1    <= x1 + 1;
        error <= error + signed(yincr);

      END IF;

    END IF;

    END IF;

  END PROCESS R1;

END ARCHITECTURE comb;

-- Guénolé Lallement
-- draw any octant
-- VHDL & Logic Synthesis Coursework

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.draw_octant;                   -- to include draw_octant entity

-- Declaration of the entity draw any octant
ENTITY draw_any_octant IS

  -- swapxy negx  negy  octant
  --  0      0      0     ENE
  --  1      0      0     NNE
  --  1      1      0     NNW
  --  0      1      0     WNW
  --  0      1      1     WSW
  --  1      1      1     SSW
  --  1      0      1     SSE
  --  0      0      1     ESE

  -- swapxy: x & y swap round on inputs & outputs
  -- negx:   invert bits of x on inputs & outputs
  -- negy:   invert bits of y on inputs & outputs

  -- xbias always give bias in x axis direction, so swapxy must invert xbias
  GENERIC(
    vsize : integer := 12
    );

  PORT(
    clk, disable, resetx, draw, xbias : IN  std_logic;
    xin, yin                          : IN  std_logic_vector(vsize-1 DOWNTO 0);
    done                              : OUT std_logic;
    x, y                              : OUT std_logic_vector(vsize-1 DOWNTO 0);
    swapxy, negx, negy                : IN  std_logic
    );
END ENTITY draw_any_octant;

-- Declaration of the architecture of draw_any_octant
ARCHITECTURE arc OF draw_any_octant IS

  -- Intern signals
  -- connection to draw_octant entity
  -- inputs: x_in, y_in, x_bias | outputs: x_out, y_out
  SIGNAL x_in, y_in, x_out, y_out : std_logic_vector(vsize-1 DOWNTO 0);
  SIGNAL x_bias                   : std_logic;

  -- connection to RD entity
  -- inputs: negx, negy, swapxy | outputs: negx_out, neg_out, swapxy_out
  SIGNAL swapxy_out, negx_out, negy_out : std_logic;

  -- connection to swap_inv_input
  -- inputs: xin, yin, swapxy, negx, negy | outputs: x_in, y_in
  -- intern signals : x_si_in_int, y_si_in_int
  SIGNAL x_si_in_int, y_si_in_int : std_logic_vector(vsize-1 DOWNTO 0);

  -- connection to swap_inv_output
  -- inputs: x_out, y_out, swapxy_out, negx_out, negy_out | outputs: x, y
  -- intern signals : x_si_out_int, y_si_out_int
  SIGNAL x_si_out_int, y_si_out_int : std_logic_vector(vsize-1 DOWNTO 0);

BEGIN
  -- Instantiation of draw_octant entity
  d_o_inst_1 : ENTITY draw_octant
    GENERIC MAP(vsize)
    PORT MAP (
      clk  => clk, resetx => resetx, draw => draw, xbias => x_bias, disable => disable,
      xin  => x_in, yin => y_in,
      done => done,
      x    => x_out, y => y_out
      );

-- Notice: it is also possible to define RD, INV and SWAP as subentities.
-- Yet behavioural process take less text to describe small blocks.

  -- RD
  RD : PROCESS(clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF disable = '0' THEN
        swapxy_out <= swapxy;
        negx_out   <= negx;
        negy_out   <= negy;
      ELSE                              -- condition if disable 0
        NULL;
      END IF;
    END IF;
  END PROCESS RD;

  -- XOR process
  xor_p : PROCESS(xbias, swapxy)
  BEGIN
    x_bias <= swapxy XOR xbias;
  END PROCESS xor_p;

  -- SWAP/INV input
  swap_inv_input : PROCESS(xin, yin, swapxy, negx, negy, x_si_in_int, y_si_in_int)
  BEGIN
    -- SWAP
    x_si_in_int <= xin;
    y_si_in_int <= yin;

    IF swapxy = '1' THEN
      x_si_in_int <= yin;
      y_si_in_int <= xin;
    END IF;

    -- INV
    x_in <= x_si_in_int;
    y_in <= y_si_in_int;

    IF negx = '1' THEN
      x_in <= NOT x_si_in_int;
    END IF;

    IF negy = '1' THEN
      y_in <= NOT y_si_in_int;
    END IF;
  END PROCESS swap_inv_input;


  -- SWAP/INV output
  swap_inv_output : PROCESS(x_out, y_out, swapxy_out, negx_out, negy_out, x_si_out_int, y_si_out_int)
  BEGIN
    -- SWAP
    x <= x_si_out_int;
    y <= y_si_out_int;

    IF swapxy_out = '1' THEN
      x <= y_si_out_int;
      y <= x_si_out_int;
    END IF;

    -- INV
    x_si_out_int <= x_out;
    y_si_out_int <= y_out;

    IF negx_out = '1' THEN
      x_si_out_int <= NOT x_out;
    END IF;

    IF negy_out = '1' THEN
      y_si_out_int <= NOT y_out;
    END IF;
  END PROCESS swap_inv_output;
END ARCHITECTURE arc;

-- Guénolé Lallement
-- ram fsm
-- VHDL & Logic Synthesis Coursework

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

-- Declaration of the entity ram_fsm
ENTITY ram_fsm IS
  PORT(
    clk, reset, start  : IN  std_logic;
    delay, vwrite      : OUT std_logic;
    addr, data         : IN  std_logic_vector;
    addr_del, data_del : OUT std_logic_vector
    );
END ENTITY ram_fsm;

-- Declaration of the architecture ram_fsm
ARCHITECTURE synth OF ram_fsm IS
  TYPE state_t IS (m3, m2, m1, mx);     -- State of the FSM
  SIGNAL state : state_t;

BEGIN
  -- process to generate data and address
  RD : PROCESS(clk)
  BEGIN
    IF falling_edge(clk) THEN
      addr_del <= addr;
      data_del <= data;
    END IF;
  END PROCESS RD;

  -- registered process for the state of the FSM
  state_machine : PROCESS(clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF reset = '1' THEN               -- Reset state from any state
        state <= mx;
      END IF;

      CASE state IS
        WHEN mx =>
          IF start = '1' THEN
            state <= m1;
          END IF;
        WHEN m1 =>
          state <= m2;
        WHEN m2 =>
          state <= m3;
        WHEN m3 =>
          IF start = '1' THEN
            state <= m1;
          ELSE
            state <= mx;
          END IF;
        WHEN OTHERS => NULL;
      END CASE;
    END IF;
  END PROCESS state_machine;

  -- conbinationnal process to generate the output
  state_process : PROCESS(reset, start, state)
  BEGIN
    IF reset = '1' THEN
      delay  <= '0';
      vwrite <= '0';
    END IF;

    vwrite <= '0';
    delay  <= start;

    CASE state IS
      WHEN mx =>
        delay <= '0';
      WHEN m1 =>
        NULL;
      WHEN m2 =>
        delay <= start;
      WHEN m3 =>
        delay  <= '0';
        vwrite <= '1';
      WHEN OTHERS => NULL;
    END CASE;
  END PROCESS state_process;
END ARCHITECTURE synth;
