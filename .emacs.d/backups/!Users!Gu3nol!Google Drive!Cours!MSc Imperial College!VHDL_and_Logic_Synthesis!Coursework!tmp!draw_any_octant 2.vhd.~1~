LIBRARY IEEE;
LIBRARY WORK;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE WORK.draw_octant;

ENTITY draw_any_octant IS

  -- swapxy negx  negy  octant
  --  0      0      0     ENE
  --  1      0      0     NNE
  --  1      1      0     NNW
  --  0      1      0     WNW
  --  0      1      1     WSW
  --  1      1      1     SSW
  --  1      0      1     SSE
  --  0      0      1     ESE

  -- swapxy: x & y swap round on inputs & outputs
  -- negx:   invert bits of x on inputs & outputs
  -- negy:   invert bits of y on inputs & outputs

  -- xbias always give bias in x axis direction, so swapxy must invert xbias
  GENERIC(
    vsize: INTEGER := 6
  );
  
  PORT(
    clk, clk_en, resetx, draw, xbias : IN  std_logic;
    xin, yin                 : IN  std_logic_vector(vsize-1 DOWNTO 0);
    done                     : OUT std_logic;
    x, y                     : OUT std_logic_vector(vsize-1 DOWNTO 0);
    swapxy, negx, negy       : IN  std_logic
    );
END ENTITY draw_any_octant;

ARCHITECTURE comb OF draw_any_octant IS
  
  ALIAS slv IS std_logic_vector;
  SIGNAL xa, xb, xc, xd, ya, yb, yc, yd: slv(vsize-1 DOWNTO 0); 
  SIGNAL negx_d, negy_d, swapxy_d, xbias_final: std_logic;


BEGIN
  D1: ENTITY draw_octant PORT MAP (clk, clk_en, resetx, draw, xbias_final, xb, yb, done, xc, yc);
  -- swap: PROCESS(xin, yin, swapxy, xd, yd, swapxy_d)
  
  rd_proc: PROCESS
  BEGIN
    WAIT UNTIL clk'EVENT AND clk='1' AND clk_en='1';
    negx_d <= negx;
    negy_d <= negy;
    swapxy_d <= swapxy;
  END PROCESS rd_proc;
  
  
  swap_invert_xor_proc: PROCESS(xbias, xin, yin, swapxy, negx, negy,
    xa, xb, xc, xd, ya, yb, yc, yd, negx_d, negy_d, swapxy_d)
  BEGIN
    xa <= xin;
    ya <= yin;
    
    IF swapxy = '1' THEN
      xa <= yin;
      ya <= xin;
    END IF;
    
    xb <= xa;
    yb <= ya;
    
    IF negx = '1' THEN
      xb <= not xa;
    END IF;
    
    IF negy = '1' THEN
      yb <= not ya;
    END IF;
    
    xb <= xa;
    yb <= ya;
    
    IF negx = '1' THEN
      xb <= not xa;
    END IF;
    
    IF negy = '1' THEN
      yb <= not ya;
    END IF;
    
    xd <= xc;
    yd <= yc;
    
    IF negx_d = '1' THEN
      xd <= not xc;
    END IF;
    
    IF negy_d = '1' THEN
      yd <= not yc;
    END IF; 
    
    x <= xd;
    y <= yd;
    
    IF swapxy_d = '1' THEN
      x <= yd;
      y <= xd;
    END IF;
    
    xbias_final <= xbias XOR swapxy;
    
  END PROCESS swap_invert_xor_proc;
  


END ARCHITECTURE comb;

