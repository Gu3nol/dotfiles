LIBRARY IEEE;
LIBRARY WORK;

USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE WORK.draw_octant;
USE WORK.draw_any_octant;
USE WORK.config_pack.ALL;
USE WORK.project_pack.ALL;

ENTITY draw_block IS
  PORT(
    clk, reset  : IN std_logic;
    host_down   : IN host_db_downstream;
    host_up     : OUT host_db_upstream;
    rcb_up      : IN db_rcb_upstream;
    rcb_down    : OUT db_rcb_downstream;
    finished    : OUT std_logic
  );
END ENTITY draw_block;

ARCHITECTURE rtl OF draw_block IS
  TYPE state_t IS (invalid, idle, set, configure, draw, clear);
  SIGNAL state : state_t;
  
  -- Previous and current coordinates and pen stored in a register.
  SIGNAL x0, y0, x1, y1 : unsigned(VSIZE-1 DOWNTO 0);
  SIGNAL pen : slv2;
  
  -- Unpacked host command.
  SIGNAL host_x, host_y : unsigned(VSIZE-1 DOWNTO 0);
  SIGNAL host_op, host_pen : slv2;
  
  -- Control signals to and from the draw_any_octant.
  SIGNAL dao_clk_en, dao_draw, dao_reset, dao_swapxy, dao_negx, dao_negy, dao_done, dao_xbias : std_logic;
  SIGNAL dao_xin, dao_yin, dao_xout, dao_yout : std_logic_vector(VSIZE-1 DOWNTO 0);
  
  -- Configuration of the multiplexer selecting what coordinates to route to the RCB.
  TYPE rcb_coord_t IS (rcb_invalid, rcb_xy1, rcb_dao);
  SIGNAL rcb_coord_select : rcb_coord_t;
  
BEGIN
  dao : ENTITY draw_any_octant PORT MAP ( -- draw any octant entity from exercise 2
    clk, dao_clk_en, dao_reset, dao_draw, dao_xbias,
    dao_xin, dao_yin,
    dao_done,
    dao_xout, dao_yout,
    dao_swapxy, dao_negx, dao_negy 
  );
  
  -- Disassembly process unpacking the command from the host.
  -- [combinational]
  host_unpacker: PROCESS(host_down.hdb)
  BEGIN
    host_x   <= unsigned(host_down.hdb(13 DOWNTO 8));
    host_y   <= unsigned(host_down.hdb(7 DOWNTO 2));
    host_op  <= host_down.hdb(15 DOWNTO 14);
    host_pen <= host_down.hdb(1 DOWNTO 0);
  END PROCESS host_unpacker;
  
  -- Process providing the host with feedback whether the DB is ready to accept new commands.
  host_feedback: PROCESS(state, rcb_up.delay, host_down.start)
  BEGIN
    IF state = idle AND rcb_up.delay = '0' THEN
      host_up.busy <= '0';
    ELSE
      host_up.busy <= '1';
    END IF;
    
    IF state = idle AND host_down.start = '0' THEN
      finished <= '1';
    ELSE
      finished <= '0';
    END IF;
  END PROCESS host_feedback;
  
  -- State machine process.
  -- [clocked]
  state_chooser: PROCESS
    VARIABLE swap, negx, negy : boolean;
  BEGIN
    WAIT UNTIL clk'EVENT AND clk = '1';
    -- Only consider changing the state when the RCB is not operating and the
    -- draw_any_octant is not doing anything.
    IF reset = '1' THEN
      state <= idle;
      x0 <= (OTHERS => '0');
      y0 <= (OTHERS => '0');
      x1 <= (OTHERS => '0');
      y1 <= (OTHERS => '0');
      pen <= (OTHERS => '0');
      rcb_down.start <= '0';
      rcb_coord_select <= rcb_xy1;
      dao_reset <= '0';
      dao_draw <= '0';
      
    ELSIF rcb_up.delay = '0' THEN
      -- Upon every transition out of the idle state.
      IF state = idle AND host_down.start = '1' THEN
        -- Shift the coordinates host -> x1,y1 -> x0,y0
        x0 <= x1;
        y0 <= y1;
        x1 <= host_x;
        y1 <= host_y;
        pen <= host_pen;
        
        -- SET command
        IF host_op = movepen_h THEN
          state <= set;
          
          -- Send a SET command to the RCB.
          rcb_coord_select <= rcb_xy1; -- x1,y1 will be host_x,host_y shortly after this
          rcb_down.cmd <= move_d;
          rcb_down.start <= '1';
          
        -- DRAW command
        ELSIF host_op = drawline_h THEN
          state <= configure;
          
          -- Prepare the negx, negy, swapxy signals.
          dao_swapxy <= '0';
          dao_negx <= '0';
          dao_negy <= '0';
          swap := abs(signed(resize(host_x, VSIZE+1) - x1)) < abs(signed(resize(host_y, VSIZE+1) - y1));
          negx := unsigned(host_x) < unsigned(x1);
          negy := unsigned(host_y) < unsigned(y1);
          IF swap THEN
            dao_swapxy <= '1';
          END IF;
          IF (negx AND not swap) OR (negy AND swap) THEN
            dao_negx <= '1';
          END IF;
          IF (negy AND not swap) OR (negx AND swap) THEN
            dao_negy <= '1';
          END IF;
          IF negx xor negy THEN
            dao_xbias <= '0';
          ELSE
            dao_xbias <= '1';
          END IF;
          
          -- Initialize the dao with the start location.
          dao_reset <= '1';
          dao_xin <= std_logic_vector(x1);
          dao_yin <= std_logic_vector(y1);
          
        -- CLEAR command
        ELSIF host_op = clearscreen_h THEN
          state <= clear;
          
          -- Send the CLEAR command to the RCB.
          rcb_coord_select <= rcb_xy1;
          rcb_down.cmd(2) <= '1';
          rcb_down.cmd(1 DOWNTO 0) <= host_pen;
          rcb_down.start <= '1';
          
        END IF;
      
      -- Recover from the set command.
      ELSIF state = set THEN
        state <= idle;
        rcb_down.start <= '0';
        
      -- Continue after configuration of the DAO.
      ELSIF state = configure THEN
        state <= draw;
        
        -- Initialize the dao with the target location.
        dao_reset <= '0';
        dao_draw <= '1';
        dao_xin <= std_logic_vector(x1);
        dao_yin <= std_logic_vector(y1);
        
      -- Wait for the drawing operation to finish.
      ELSIF state = draw THEN
        dao_draw <= '0';
        IF dao_done = '1' THEN
          state <= idle;
          rcb_down.start <= '0';
        ELSE
          rcb_down.start <= '1';
          rcb_down.cmd(2) <= '0';
          rcb_down.cmd(1 DOWNTO 0) <= pen;
          rcb_coord_select <= rcb_dao;
        END IF;
      
      -- Recover from the clear command.
      ELSIF state = clear THEN
        state <= idle;
        rcb_down.start <= '0';
        
      END IF;
    END IF;
  END PROCESS state_chooser;
  
  -- Process that decides whether to run the DAO or not.
  -- [combinational]
  dao_inhibitor: PROCESS(state, rcb_up.delay)
  BEGIN
    IF state = configure OR state = draw THEN
      dao_clk_en <= not rcb_up.delay;
    ELSE
      dao_clk_en <= '1';
    END IF;
  END PROCESS dao_inhibitor;
  
  -- Multiplexer process routing one of the available coordinates through to
  -- the RCB.
  -- [combinational]
  rcb_coord_mux: PROCESS(rcb_coord_select, x1, y1, dao_xout, dao_yout)
  BEGIN
    rcb_down.x <= (OTHERS => 'U');
    rcb_down.y <= (OTHERS => 'U');
    CASE rcb_coord_select IS
    WHEN rcb_xy1 =>
      rcb_down.x <= std_logic_vector(x1);
      rcb_down.y <= std_logic_vector(y1);
    WHEN rcb_dao =>
      rcb_down.x <= dao_xout;
      rcb_down.y <= dao_yout;
    WHEN OTHERS => NULL;
    END CASE;
  END PROCESS rcb_coord_mux;
  
END ARCHITECTURE rtl;